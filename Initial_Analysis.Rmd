---
title: "Initial Analysis"
author: "Juliano Palacios-Abrantes"
date: '2019-02-04'
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r setup, eval = T, echo=F, warning=F,message=F, results='hide'}

#### READ ME !!! ####
# Run this chunk before knit so you make sure you have all pkgs installed in R

ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE,repos = "http://cran.us.r-project.org")
  sapply(pkg, require, character.only = TRUE)
}


#### Library ####
packages <- c(
  "readxl", # Read dataframe
  "data.table", # Read dataframe (Fast!)
  "dplyr", # Data manipulation
  "tidyr", # Data manipulation
  "ggplot2", #Nice grpahs and spatial analysis
  "wesanderson",
  "circlize", # For circular plot
  "ggimage", #for reading images to the circular plot
  # "cowplot",
  # "rgdal",
  # "RColorBrewer",
  # "knitr",
  # "kableExtra",
  "ggrepel", # for nice plot labels
  "ggsflabel", # for nice sf_plots labels
  # "gridExtra",
  # "ggmap",
  # "rgeos",
  # "stringr",
  # "stringer",
  "spdep", # for poly2nb
  "sf", #Spatial analysis 
  "sp", #Spatial analysis 
  "purrr",#Spatial analysis
  "rgdal", #Spatial analysis
  "tools", #Spatial analysis 
  # "png", # For reading plots in chunk codes
  # "grid" # For reading plots in chunk codes
  "parallel", # for parallelization
  "taxize", # For getting species names
  "rfishbase", # for species ecosystem affinity
  "zoo" #for runing mean
)

ipak(packages)

ggtheme_map <- function(base_size = 9, Region = "NA") {
  
  theme(text             = element_text(#family = "Helvetica",
    color = "gray30", size = base_size),
    plot.title       = element_text(size = rel(1.25), hjust = 0, face = "bold"),
    panel.background = element_blank(),
    panel.border     = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "transparent"),
    strip.background =element_rect(fill = "transparent"),
    strip.text.x = element_text(size = 18, colour = "black",face= "bold.italic", angle = 0),
    axis.line        = element_blank(), # element_line(colour = "grey30", size = .5))
    axis.ticks       = element_blank(),
    axis.text        = element_blank(),
    axis.title       = element_blank(),
    legend.key       = element_rect(colour = NA, fill = NA, size = 4),
    legend.position = "bottom",
    legend.key.width =unit(6,"line")
  )
}

ggtheme_plot <- function() {
  theme(
    plot.title = element_text(size = rel(1), hjust = 0, face = "bold"),
    panel.background = element_blank(),
    strip.background = element_blank(),
    # strip.text       = element_text(size = base_size, face = "italic"),
    panel.border     = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank(),
    axis.ticks = element_blank(),
    axis.text.x = element_text(size = 12,
                               angle = 0,
                               face = "plain"),
    axis.text.y = element_text(size = 12),
    axis.title = element_text(size = 14),
    legend.key = element_rect(colour = NA, fill = NA),
    legend.position  = "right",
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    strip.text.x = element_text(size = 12, colour = "black"),
    strip.text = element_text(size = 12)
  )
}

#### Set paths for computer ####


# Set paths depending on machine Beast (jepa88), "carmelia" or Hall1000
if(Sys.info()[7] == "jepa88"){
  Data_Path <- "Z:/JULIANO_NEYMAR/FishForVisa/"
  }
if(Sys.info()[7] == "carmelia"){
  Data_Path <- "~/GitHub/FishForVisa/Temporal_Data/"
}
if(Sys.info()[7] == "hall1000"){
  Data_Path <- "/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/"
}

# Setting up paths 
# If path exists overrite it, otherwise creats a new path for that year

# Path for saving Results
Results_Path = paste(Data_Path,"Results/",sep = "")
if(file.exists(Results_Path) == TRUE){
  Results_Path = paste(Data_Path,"Results/",sep = "")
}else{
  dir.create(paste(Data_Path,"Results/",sep = ""))
  Results_Path = paste(Data_Path,"Results/",sep = "")
}

# Path for saving Figures
Figures_Path = paste(Data_Path,"Figures/",sep = "")

if(file.exists(Figures_Path) == TRUE){
  Figures_Path = paste(Data_Path,"Figures/",sep = "")
}else{
  dir.create(paste(Data_Path,"Figures/",sep = ""))
  Figures_Path = paste(Data_Path,"Figures/",sep = "")
}

### Message for my brain

print("_____________________ WARNING DO NOT FORGET TO PULL/PUSH BEFORE YOU START_____________________")

```


# Methods

These are the methods to follow:

1. Determine which countries have Neighbouring EEZs  
  1.1. For this we used the Sea Around Us EEZ map that discriminate by oceans and a routine (*Estimate Transboundary Species*) to identify Neighbouring polygons,
  1.2. Then we match the SAU spatial information (e.g. INDEX within EEZ and coordinates) with the Neighbouring data

2. Overlap distribution maps with Neighbours data  
  2.1. For each species we merged the Neighbours data with their known distribution (SAU distribution and catch,ESMs, and Observation)  
3. Determine transboundary if:  
  3.1. Species is present in both Neighbouring EEZs by INDEX  

We create two "confidence level" based on data and area covered, i.e;

-
-

## Determine species list

This part is to determine the list of species to be analized in the project. Initially this list was limited by the species data from the DBEM, however, as we are not using the DBEM, the limit is now the SAU.

```{r Speceis_List_For_Data, eval = F, echo = T}

# Get the DBEM list of species to extract from other modesl
#GFDL
DBEM_species_G <- data_frame(TaxonKey = list.files("/Volumes/DATA/DATA/DBEM/GFDL26F1"))
#IPSL
DBEM_species_I <- data_frame(TaxonKey = list.files("/Volumes/DATA/DATA/DBEM/IPSL26F1"))
#MPI
DBEM_species_M <- data_frame(TaxonKey = list.files("/Volumes/DATA/DATA/DBEM/MPI26F1"))


# Merge the, and save to send to gabs

DBEM_Species_List <- DBEM_species_I %>% 
  bind_rows(DBEM_species_G,
            DBEM_species_M) %>% 
  group_by(TaxonKey) %>% 
  summarise() %>% 
  filter(str_detect(TaxonKey, "^6"))


# Include species name, as well... 

exploited_species <- read.csv("/Volumes/DATA/PROJECTION exploited species ENM/exploited_species_list.csv")

DBEM_Species_List <- DBEM_Species_List %>% 
  left_join(exploited_species,
            by ="TaxonKey")


# write.csv(DBEM_Species_List,
#           "DBEM_Species_List.csv",
#           row.names = F)


# Send second set of species

# Get species already modelled
# Removes everything before the number
Step_One <- gsub(".*_","",list.files(paste(Data_Path,"/Distribution_Data/SAU_Distribution/",sep="")))

# Species List
Species_List <- gsub("\\..*","",Step_One)

exploited_species <- read.csv("/Volumes/DATA/PROJECTION exploited species ENM/exploited_species_list.csv") #%>% 
  # left_join(Spp_Clasification) %>% 
  # filter(!is.na(DemPel)) # remove freshwater spp

# Get all species in SAU database (2080)
Species_list <- exploited_species %>% 
  rename(scientific_name = TaxonName) %>% 
  pull(scientific_name)

# get their environ. association according to FishBase (species())

Species_environ_list <- rbind(species(Species_list, 
                                      fields = species_fields$habitat)
                              ) %>% 
  mutate(TaxonName = Species_list) %>% 
  left_join(exploited_species,  by ="TaxonName") %>% 
  filter(!TaxonKey %in% Species_List) %>% 
  filter(Saltwater == -1) %>%  # remove those that are not happy with saltwater
  select(TaxonKey,TaxonName,CommonName)

# write.csv(Species_environ_list,
#           "Transboundary_Spp_Set2.csv",
#           row.names = F)

# Sent to Gabs Seprember 16th

### Check Gabs Data ####

# Does all data have the same number of files?

# SAU <- length(list.files("/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Distribution_Data/SAU_Distribution/"))
# ENM <- length(list.files("/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Distribution_Data/ENM/"))
# Occ <- length(list.files("/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Distribution_Data/Occurence/"))

####### Yes they do! ####

```

## Determine Neighbourds

This is the first step of the analysis and will determine what EEZs are neighbouring. THe routine creates a final dataset that we then use to estimate transboundary species.

### Function `EstNeighbours`

This function determines what EEZs are Neighbours and returns a data.frame of it

```{r funEstNeighbours, eval = F, echo=T}
# Determine which countries are Neighbours

EstNeighbours <- function(Shapefile, Partial = "NA"){
  
  # Get sparse matrix
  int = suppressMessages(st_intersects(Shapefile))
  # Warnning message
  # although coordinates are longitude/latitude, st_intersects assumes that they are planar

  
  # Intitalize new object
  mat = NULL
  
  # Fill
  for(i in 1:NROW(int)){
    #Create matrix with ID and intersecting IDs
    tmp = cbind(i, int[[i]])
    
    # Join to Initalized object
    mat  = rbind(mat, tmp)
  }
  
  # Build final data.frame substituting ID for name (in this case nc$name)
  Result_table = data.frame(Name = Shapefile$Name[mat[,1]], 
                            Neighbour_Territory = Shapefile$Name[mat[,2]]
  )
  
  # Remove duplicates... eg of course an object intersects with itself...
  Result_table = Result_table[Result_table$Name != Result_table$Neighbour_Territory,]
  
  if(Partial == T){
    # If only partial analysis just returns Neighbour list
    return(Result_table)
    
  }else{
    
  # Merge them with SAU data so we have the INDEX and lat long info
  suppressWarnings(
    # warning for characters in name, no problem
  DBEM_Neighbours_Data <- Result_table %>% 
     left_join(EEZIDs_List, 
              by = "Name") %>% # Asign EEZ id to each country
    left_join(EEZ_CellID, 
              by = "EEZID") %>% # Asign EEZ id to each country
    left_join(Coor,
              by = "INDEX") %>%  # Include lat long
    rename(Country_Territory = Name)
  
  )
  
  return(DBEM_Neighbours_Data)
  
  } # end ifelse
} # end function


# subset <- World_EEZs %>% filter(Name %in% c("Chile","Peru"))
# EstNeighbours(subset)
# EstNeighbours(subset,T)

```

### Sub Routine; Neighbours

```{r Neighbours_Control_Pannel, eval = F, echo = F}

###___________________Read Me_____________________#
#### Using the SAU shapefile that contains EEZ per ocean (E.G. Mexico Pacific and Mexico Atlantic)
###_______________________________________________#

# SAU shapefile

# The path
path_world <- paste(Data_Path,"Spatial_Data/SAU_Shapefile/",sep="")

# The File
fnam_world <- "SAUEEZ_July2015.shp"

# Load it!
World_EEZs <- st_read(dsn = path_world,
                      layer =file_path_sans_ext(fnam_world))

#### Grid cell information ####

# List of DBEM INDEX within the EEZ 
#Data provided by Vicki Lam

EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))
EEZ_CellID <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/EEZ_CellID.xlsx",sep=""))

colnames(EEZ_CellID) <- c("EEZID","INDEX")

# DBEM Coordinate system
Coor <- fread(paste(Data_Path,"Spatial_Data/Lon_Lat_DBEM.txt",sep=""),header = FALSE)
colnames(Coor) <- c("INDEX","Longitude","Latitude")

```

```{r Neighbours_Subroutine, eval = F, echo = T}

# Run Function (Ran and saved May 27 2019 at 6pm)
 system.time(
  EEZ_Neighbour_List <- EstNeighbours(World_EEZs, Partial = T)
 )
# 8203.05    0.25 8204.51 (around 2 hours 30 min)

write.csv(EEZ_Neighbour_List,
          paste(Data_Path,"Spatial_Data/EEZ_Neighbour_List.csv", sep =""),
          row.names = F)




####_________________________________________ TESTING PERIOD_________________________________________###
# I'm substetting central america to do the whole analysis (smaller EEZs = faster computation) once I have figure out things I'll run for all

### Data
# For now using only the subdata

## Spatial Test Data
# SAU_Regions <- as.data.frame(unique(World_EEZs$Name))

# Test_Countries <-c("Guatemala (Caribbean)","Guatemala (Pacific)","Belize","Honduras (Pacific)","El Salvador","Costa Rica (Pacific)","Costa Rica (Caribbean)", "Panama (Caribbean)", "Panama (Pacific)")

# Test <- World_EEZs[World_EEZs@data$Name %in% Test_Countries, ]

```


## Determine Species Status

This sub routine determines the species exploitation status based on the SAU methodology. **Note:** For the current project we do not consider this method to determine the species exploitation status *per se*, but rather a catch trend that *could* indicate that a species is under/over/max exploited.

In the original method the authors analyze stocks, while we analyze at the species level within each EEZ. Also (n), the number of species, is defined as a time series of a given species, genus or family (higher and pooled groups have been excluded) for which the first and last reported landings are at least 10 years apart, for which there are at least 5 years of consecutive catches and for which the catch in a given area (LME) is at least 1000 tonnes. We removed the last one (LME) and computed all of the species that only followed the first two;
 
1) The first and last reported landings are at least ten years apart;

2) There are at least five years of consecutive catches

Once those tresholds are met, the status of the species is determined as follows:

- Rebuilding (Recovering)	Year of landing > year of post-max. min. landing AND post-max. min. landing < 10% of max. landing AND landing is 10-50% of max. landing
- Developing	Year of landing < year of max. landing AND landing is < or = 50% of max. landing OR year of max. landing = final year of landing
- Exploited	Landing > 50% of max. landing
- Over exploited	Year of landing > year of max. landing AND landing is between 10-50% of max. landing
- Collapsed	Year of landing > year of max. landing AND landing is < 10% of max. landing

*Notes* = 3 years average mean

### Function `GetSppDist`

This function reads in species distribution from the observation data, ESM models and SAU data.

```{r GetSppDist, eval = T, echo = T}

#### The function
# NOTES
# For now we're using only the last 10 years average, basicaaly if the species has been fished in any of these years, its considered present

GetSppDist=function(Spp,Model,Coord){
  
  Distpath <- paste(Data_Path,"Distribution_Data/",sep="")
  INDEX = seq(1,259200,1)
  # INDEX <- Coordinates$INDEX
  
  # SAU Distributions
  if(Model == "SAU_D"){
    File_Name <- paste("SAU_Distribution/DIST_GOOD_SP_")
  }
  
  # SAU Catch
  if(Model == "SAU_C"){
    File_Name <- paste("SAU_data_per_species/CATCH_SP_")
  }
  
  # Occurence
  if(Model == "Occ"){
    File_Name <- paste("Occurence/OCCURENCE_JULIANO_")
  }
  
  # ENM Model
  if(Model == "ENM"){
    File_Name <- paste("ENM/ENM_JULIANO_")
  }
  
  # DBEM Data
  # if(Model == "DBEM"){
  #   Distpath <- "/Volumes/DATA/JULIANO_NEYMAR/PristineSeasData
  #   Final_Path <- "ENM"
  #   File_Name <- paste("ENM_JULIANO",Spp,".mat",sep="")
  # }
  
  if(Model == "All"){
    
    Models_List <- c(paste(Distpath,"SAU_Distribution/DIST_GOOD_SP_",Spp,".mat",sep =""),
                     paste(Distpath,"Occurence/OCCURENCE_JULIANO_",Spp,".mat",sep=""),
                     paste(Distpath,"ENM/ENM_JULIANO_",Spp,".mat",sep="")
    )
    
    # Jumps species not modeled. NOTE: We only need one as ENM, Occ and SAU Dis have all the same 939 spp
    if(file.exists(Models_List[1])){
      
      Load <- lapply(Models_List, FUN=R.matlab::readMat, na.strings=0)
      
      sppdist <- as.data.frame(bind_cols(Load)) %>% 
        mutate(
          INDEX = INDEX,
          TaxonKey = Spp
        )
      colnames(sppdist) <- c("SAU_D","Occ","ENM","INDEX","TaxonKey")
      
      #### Step for SAU catch data that has to be averaged
      File_Name <- paste("SAU_data_per_species/CATCH_SP_")
      SppPath <- paste(Distpath,File_Name,Spp,".mat",sep="")
      
      # For now we're using only the last 10 years average, basicaaly if the species has been fished in any of these years, its considered present
      SAU_C_data <- as.data.frame(R.matlab::readMat(SppPath)) %>% 
        select(CATCH.1:CATCH.65) %>% 
        mutate(INDEX = INDEX) %>% 
        gather("Year","Catch",CATCH.56:CATCH.65) %>% # Last 10 years of data
        group_by(INDEX) %>% 
        summarise(SAU_C = mean(Catch,na.rm=T))
      
      # Join both tables
      sppdist <- sppdist %>% 
        left_join(SAU_C_data,
                  by = "INDEX") %>% 
        select(TaxonKey,INDEX,everything()) %>% 
        left_join(CoorG,
                  by = "INDEX")
      
      # Fix coordinate system incompatibility between Gab and DBEM
      sppdist <- suppressWarnings(sppdist[order(sppdist$Latitude, rev(sppdist$Longitude),decreasing=TRUE), ] %>% 
                                    mutate(INDEX = seq(1,259200,1)) %>% 
                                    gather("Model","Value",3:6) %>%
                                    mutate(Value = ifelse(is.na(Value), 0, Value)) # Converting NA's to ceros
      )
      
      getSppDist = sppdist
      
    }
    
  }else{  
    
    # Merge paths
    SppPath <- paste(Distpath,File_Name,Spp,".mat",sep="")
    
    if(file.exists(SppPath) == TRUE){
      
      #Install (if needed) R.matlab package
      if(!require(R.matlab)){
        install.packages("R.matlab")
      }
      
      # Read Files
      
      sppdist <- as.data.frame(R.matlab::readMat(SppPath)) %>% 
        mutate(INDEX = INDEX,
               Species = Spp) %>% 
        left_join(Coord) 
      
      # Fix coordinate system incompatibility between Gab and DBEM
      sppdist <- sppdist[order(sppdist$Latitude, rev(sppdist$Longitude),decreasing=TRUE), ] %>% 
        mutate(INDEX = seq(1,259200,1))
      
      # Return 
      getSppDist=sppdist
      
    }else{
      print(paste("No info for this species",Spp, "in",Model))
    }
    
  }
}

#______ Test ______#

# Variables outside function
# head(GetSppDist(600004,"SAU_D")) # Works
# head(GetSppDist(600004,"SAU_C")) # Works
# head(GetSppDist(600004,"Occurence")) # Works
# head(GetSppDist(600004,"ENM")) # Works
# head(GetSppDist(600004,"All")) # Works


```

### Function `EstSppStatus`

This function estimates the exploitation status of a species based on catch data.

```{r funEstSppStatus, eval = T, echo =F}

EstSppStatus <- function(Spp,Coord){
  
  # Load species' data
  Data <- GetSppDist(Spp, Model = "SAU_C", Coord = Coord) %>% 
    set_names(c(seq(1950,2014,1),"INDEX","Species","Longitude","Latitude")) %>% 
    gather("Year","Value",`1950`:`2014`) %>%
    arrange(INDEX) %>% 
    left_join(Index_Code,
              by = "INDEX") %>% 
    filter(!is.na(EEZID),
           Value > 0) %>% 
    group_by(TaxonKey=Species,Year,Territory) %>% # Estimates total catch per country
    summarise(Total_Catch = sum(Value,na.rm=T)) %>% 
    group_by(TaxonKey,Territory,Year) %>% # Running mean as Pauly et la.
    mutate(RMean = rollmean(x = Total_Catch, 3,
                            align = "right",
                            fill = Total_Catch)
    ) %>% 
    select(-Total_Catch) %>% 
    ungroup() %>% 
    mutate(Year = as.numeric(Year))
  
  # Tresholds to evaluate stocks if these are not met, then soecies status = "No Status"
  Tresholds_Data <- Data %>% 
    arrange(Territory) %>% 
    group_by(TaxonKey,Territory, grp = cumsum(c(1, diff(Year) != 65))) %>% 
    group_by(TaxonKey,Territory) %>% 
    summarise(Years_appart = ifelse(max(Year)-min(Year) >= 0,"Yes","No"), # Step 1. first and last reported landings are at least 10 years apart
              Consecutive = ifelse(max(grp) >= 5,"Yes","No")#, # Step 2. There are at least 5 consecutive catch years
              # Catch_over = ifelse(max(RMean >= 1000),"Yes","No") # Step 3. 3) The catch in a particular area (LME) is at least 1,000 tonnes. (CURRENTLY OFF)
    ) %>% 
    gather("Step","Treshold",Years_appart:Consecutive) %>% 
    group_by(TaxonKey,Territory) %>% 
    summarise(Met_Criteria = paste(unique(Treshold),collapse =";")
    )
  
  # Remove species that do not met the criterias
  
  No_Status_Data <- Tresholds_Data %>% 
    filter(Met_Criteria != "Yes") %>% 
    select(TaxonKey,Territory) %>% 
    mutate(Status = "No Status")
  
  
  # Evaluate species that met the criteria
  
  # Get Variables to perform status metric
  Status_Data <- Data %>% 
    anti_join(No_Status_Data, # Removes no status data
              by = c("TaxonKey","Territory")
    ) %>% 
    # Get Max catch and max catch year
    group_by(TaxonKey,Territory) %>% 
    top_n(1,RMean) %>% 
    rename(Max_Peak = RMean,
           Y_Max_Peak = Year) %>% 
    # Get Min catch after peak catch
    left_join(Data,
              by = c("TaxonKey","Territory")
    ) %>% 
    filter(Year > Y_Max_Peak) %>% # Filter years after peak year
    group_by(TaxonKey,Territory) %>% 
    top_n(-1,RMean) %>% # find min value
    rename(Post_Max_Min = RMean,
           Y_Post_Max_Min = Year) %>% 
    left_join(Data,
              by = c("TaxonKey","Territory")
    ) %>% 
    # Final Species Status Evaluation 
    mutate(Status = ifelse(Year > Y_Post_Max_Min & Post_Max_Min < (Max_Peak*0.10) & (RMean > (Max_Peak*0.10) & RMean < (Max_Peak*0.50)),"Rebuilding",
                           ifelse((Year < Y_Max_Peak & RMean <= (Max_Peak*0.50) | Y_Max_Peak == max(Year)),"Developing",
                                  ifelse(RMean > Max_Peak*0.50,"Max Exploited",
                                         ifelse(Year > Y_Max_Peak & (RMean > (Max_Peak*0.10) & RMean < (Max_Peak*0.50)),"Over Exploited",
                                                ifelse(Year > Y_Max_Peak & RMean < Max_Peak*0.10,"Collapsed",
                                                       "No Status")
                                         )
                                  )
                           )
    )
    ) %>% 
    filter(Year > 2004) %>% # last 10 years of data
    group_by(TaxonKey,Territory,Status) %>% 
    summarise(n_Status= n()) %>% 
    group_by(TaxonKey,Territory) %>% 
    top_n(1,n_Status) %>%
    select(-n_Status)
  
  # Function Return 
  
  # If both datasets have value RETURN BOTH
  if(nrow(No_Status_Data) > 0 & nrow(Status_Data) > 0){
    
    Fun_Result <- bind_rows(No_Status_Data,
                            Status_Data)
  }
  
  # If only No status data, then just return No Status Data
  if(nrow(No_Status_Data) > 0 & nrow(Status_Data) == 0){
    return(No_Status_Data)
  }else{
    return(Status_Data)
  }
}

# Testing
# Test_1 <- EstSppStatus(Species_List[1],CoorG)

```

### Data Species Status

### Sub routine for Species Status

```{r Spp_Status_Control_Pannel, eval = T, echo = F}

# SAU relations between INDEX and Country's EEZs
EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))
EEZ_CellID <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/EEZ_CellID.xlsx",sep=""))
colnames(EEZ_CellID) <- c("EEZID","INDEX")

Index_Code <- EEZIDs_List %>% 
  left_join(EEZ_CellID) %>% 
  rename(Territory = Name)

# Gabriel's coordinate system
CoorG <- read.csv(paste(Data_Path,"Spatial_Data/coordinates_gab.csv",sep="")) %>%
  mutate(INDEX = seq(1,259200,1))

# Removes everything before the number
Step_One <- gsub(".*_","",list.files(paste(Data_Path,"/Distribution_Data/SAU_Distribution/",sep="")))

# Species List
Species_List <- gsub("\\..*","",Step_One)

```

```{r Spp_Status_Sub_Routine, eval = T, echo = F}
# Needs to have trans species 
Species_Status <- bind_rows(
    mclapply(
      Species_List,
      FUN = EstSppStatus,
      Coord = CoorG  # Gabriels coordinate system for read species dist
    )
  )

# Save data
# write.csv(Species_Status,
#           paste(Results_Path,"Species_Status.csv",sep=""),
#                 row.names = F)

```

## Estimate Transboundary Species

This is the main step of the project. In this segment we estimate the number of transboundary species existing today in each of the worlds EEZs.

The datasets SAU_D, OCC, and ESM are used as sppecies presence while SAU_C is used as a confirmation of that. The `Model Index` is the first treshold and estimates the uncertanty of models. Goes from 0 - 1 as follows:

- 1 or 0; All models agree that in the presence of the species
- 0.75; Three out of four models agree on speices presence
- 0.50; Two out of four models agree on speices presence
- 0.25; Only one model flags a speices presence
- 0; All models agree there is no species there


The `Area_Index` is the second treshold and estimates the proportion of each species distribution in each EEZ. It only take into consideration the distribution of the species within the two EEZs, rather than the complete distribution. Hence, is mirrord (e.g. if EEZ#1 is 0.40, EEZ#2 is 0.6)

** NOTE THAT THE FUNCTION IS SETTED TO OUTPUT RESULTS FOR ALL MODELS **

### Function `EstTransIndex`

This is the main function of the project, the one that actually estimates if a species is transboundary or not

```{r funEstTransIndex, eval= T ,echo = T,warning = F,message = F}

# Function to determine whether or not a species is transboundary

# Varibales needed
# Spp: Species to be analized, data with presence/absence per gridcell
# Index_EEZ: Reference list of all INDEX that fall within EEZs
# EEZ_Size: Number of grid-cells that each EEZ has
# Neighbours: Reference list of neighbouring countries

# Needs getSppDist

#### For testing 
# Spp <- 600004  # Anchovie Equator, Chile and Peru
# Spp <- 600107 # Tuna Many RFMOs
# Spp <- 600464 # Discrete species 
# Spp <- 600051 # One of Pierrs massive (wrong) discrete spp
# x <- c(600464, # Discreat spp in one nation
      # 600059, # nowhere to be found spp
       # 601352, # Discrete spp in two nations
       # 600004) # transboundary spp
# Model <- "All"
# Coord <- CoorG
# 
# # For EEZ
# Neighbours <- Neighbours_Data
# Index_Code <- Index_Code
 
# __________________________________ #

# The function
EstTransIndex <- function(Spp,Model = "All",Neighbours,Coord,Index_Code,Save="Y",Jurisdiction_Type){
  
  # Get model data from spps
  SppDist <- GetSppDist(Spp,Model,Coord)
  
  # Result 1. Number of Countries that share the species
  
  #____________ ESTIMATING MODEL INDEX (TRESHOLD 1)_________ #
  Trans_Spp <- SppDist %>%
    filter(INDEX %in% Neighbours$INDEX,# Filter data only located within EEZs
           Model != "SAU_C") %>% # Only using observational and modelled data
    mutate(Value = ifelse(Value > 0, 1,0)) %>%  
    filter(Value > 0) %>%
    group_by(TaxonKey,
             INDEX
    ) %>%
    summarise(Model_Index = sum(Value,na.rm=T)/3
    ) %>%
    filter(Model_Index > 0.4) %>% # at least 2 sources agree
    # ____________ ESTIMATING FUNDAMENTAL NICHE (TRESHOLD 2)_________ #
    left_join(SppDist,
              by = c("TaxonKey","INDEX")) %>%
    filter(Model == "SAU_C", # Only keeping cells where SAU catch exists
           Value > 0) %>%
    mutate(Model_Index = Model_Index*100) %>%
    select(-Model, -Value, -Latitude,-Longitude) %>%
    left_join(Index_Code,
              by = "INDEX")

  # MODEL INDEX (TRESHOLDS 1 & 2) #
  Model_Index_D <- Trans_Spp %>% 
    group_by(Territory,
             TaxonKey,
             Model_Index
    ) %>% 
    summarise(n_cells_spp = n()) %>% 
    select(-n_cells_spp)
  

  #____________ ESTIMATING DISTRIBUTION INDEX (TRESHOLD 3)_________ #
  # The number of species' cells present within each country's EEZ
  
  # if(n_Territory > 1){
  
  #Step 1.  Get EEZ id and Neighbour
  Neighbours_List <- Neighbours %>% 
    group_by(Territory,Neighbour) %>% 
    summarise(n=n()) %>% 
    ungroup() %>% 
    select(-n)
  
  # Step 2. Determines the amount of grids present in each country
  Spp_Grid <- Trans_Spp %>% 
    group_by(TaxonKey,
             Model_Index, # Un-comment after producing models x datasets
             Territory) %>% 
    summarise(n_spp_eez = length(unique(INDEX))) %>% 
    left_join(Neighbours_List,
              by = "Territory") %>% 
    filter(Territory %in% Trans_Spp$Territory, #Filter out unwanted Neighbours (those who don't have grids within but get included because they are Neighbours)
           Neighbour %in% Trans_Spp$Territory)
  
  
  # IF SPECIES DISCRETE AND APEARS IN ONLY 1 REGION OR > 1 REGION BUT NOT NEIGHBOURS #
  
  # Step 2.1. Determines discrete spp
  if(nrow(Spp_Grid) == 0 & Save == "Y"){
    
    #  Get the Territory where species happen
  Discrete_Territory <- unique(Model_Index_D$Territory)
  n_Territory <- length(Discrete_Territory)
    
    # Reads dataset of Non transboundary species
    Non_Transboundary_Data <- fread(paste(Results_Path,"Non_Transboundary_Data.csv",sep=""))
    
    # Set new data
    Current_Spp <- tibble(TaxonKey = as.integer(Spp),
                          Territory = Discrete_Territory)
    
    # Combine new spp with others
    New_Non <- Non_Transboundary_Data %>% 
      bind_rows(Current_Spp)
    
    # Set a name for file and saves data
    New_Non_Name <- paste(Results_Path,"Non_Transboundary_Data.csv",sep="")
    write.csv(New_Non, New_Non_Name, row.names = F)
    
  EstTransIndex=Current_Spp
    
  }
  
  # Step 3. Sum total grids per Neighbours
  if(nrow(Spp_Grid) > 0 & Save == "Y"){
  
  # Split dataframes to merge latter
  Territory_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      Model_Index, # Un-comment after producing models x datasets
      TaxonKey,
      Name=Territory,
      n_spp_eez
    )
  
  Neighbour_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      Model_Index,
      TaxonKey,n_spp_eez,
      Name=Neighbour,
      Territory
    )
  
  # Merge dataframes to get totals per Neighbourds
  Area_Index_D <- full_join(Territory_T,
                            Neighbour_T, 
                            by = c("Model_Index","Name","TaxonKey")
  ) %>%
    rowwise() %>%
    mutate(Spp_Total = sum(n_spp_eez.x,n_spp_eez.y,na.rm=T)) %>% # Total gridcelles per Neighbours
    distinct() %>% # Removes false duplicates from `full_join()`
    rename(Territory = Name,
           Neighbour =Territory,
           n_spp_Country = n_spp_eez.x,
           n_spp_Neighbour = n_spp_eez.y) %>% 
    mutate(Area_Index = n_spp_Country/Spp_Total) %>%  #Estimates the proportion of grids per country
    select(1:3,6,8)
    
  
  #____________ FINAL INDEX TABLE_________ #
  Indexes <- Model_Index_D %>% 
    full_join(Area_Index_D,
              by = c("TaxonKey","Territory","Model_Index")
    ) %>% 
    filter(!is.na(Area_Index),
           !is.na(Model_Index) # Uncomment after producing Models x datasets
    ) %>%  # Remove cases where the country does not pass the area_index and viceversa
    select(TaxonKey,Territory,Neighbour,everything())
  
  ### Save spp dataframe
  
  if(nrow(Indexes) > 0 & Save == "Y"){
    
    File_Name <- paste(Spp,"_Transboundary.csv",sep = "")
    Save_Path <- paste(Results_Path,File_Name,sep="")
    
    write.csv(Indexes,
              Save_Path,
              row.names = F)
    
  }
  
  if(nrow(Indexes) > 0 & Save == "N"){
  EstTransIndex=Indexes # A dataframe with   
  }
  
  ### Function return
  EstTransIndex=Indexes # A dataframe with 
    
  } # Closes Treshold (Step 3)
} # closes function

# __________________________________
# Test function
# __________________________________
 
# Spp <-  # Tuna Many RFMOs
# Model <- "All"
# Coord = CoorG
# #
# 
# # For EEZ
# Neighbours <- Neighbours_EEZ
# Index_Code <- EEZ_Index_Code
# 
# 
# EstTransIndex(Spp = 600107,
#               Mode = "All",
#               Neighbours = ,Coord,Index_Code,Save="Y")

```

### Function `Mclapply_Hack`

This function will hack the `mclappy()` function to work in PC and use multiple cores for the analysis. It was created by someone else and the original version is here: 
https://www.r-bloggers.com/implementing-mclapply-on-windows-a-primer-on-embarrassingly-parallel-computation-on-multicore-systems-with-r/


```{r Mclapply_Hack_Fun, eval= T , echo = T, warning = F, message = F}

# The hack

Mclapply_Hack <- function(...){
    ## Create a cluster
    size.of.list <- length(list(...)[[1]])

    cl <- makeCluster(min(size.of.list, n_cores))
    
  ## Find out the names of the loaded packages 
    loaded.package.names <- c(
        ## Base packages
        sessionInfo()$basePkgs,
        ## Additional packages
        names(sessionInfo()$otherPkgs))
    tryCatch( {

       ## Copy over all of the objects within scope to
       ## all clusters. 
       this.env <- environment()
       while( identical( this.env, globalenv() ) == FALSE ) {
           clusterExport(cl,
                         ls(all.names=TRUE, env=this.env),
                         envir=this.env)
           this.env <- parent.env(environment())
       }
       clusterExport(cl,
                     ls(all.names=TRUE, env=globalenv()),
                     envir=globalenv())
       
       ## Load the libraries on all the clusters
       ## N.B. length(cl) returns the number of clusters
       parLapply( cl, 1:length(cl), function(xx){
           lapply(loaded.package.names, function(yy) {
               require(yy , character.only=TRUE)})
       })
       
       ## Run the lapply in parallel 
       return( parLapply( cl, ...) )
    }, finally = {        
       ## Stop the cluster
       stopCluster(cl)
    })


## Warn the user if they are using Windows
if( Sys.info()[['sysname']] == 'Windows' ){
    message(paste(
      "\n", 
      "   *** Microsoft Windows detected ***\n",
      "   \n",
      "   For technical reasons, the MS Windows version of mclapply()\n",
      "   is implemented as a serial function instead of a parallel\n",
      "   function.",
      "   \n\n",
      "   As a quick hack, we replace this serial version of mclapply()\n",
      "   with a wrapper to parLapply() for this R session. Please see\n\n",
      "     http://www.stat.cmu.edu/~nmv/2014/07/14/implementing-mclapply-on-windows \n\n",
      "   for details.\n\n"))
}

## If the OS is Windows, set mclapply to the
## the hackish version. Otherwise, leave the
## definition alone. 
mclapply <- switch( Sys.info()[['sysname']],
   Windows = {Mclapply_Hack}, 
   Linux   = {mclapply},
   Darwin  = {mclapply})

}
## end mclapply.hack.R

```

### **Principal Routine**

```{r Trans_Spp_Control_Pannel, eval = F, echo = F}

# Set Jurisdiction to EEZ or RFMO
Jurisdiction <- "EEZ"

# Determine forlder for saving results
Results_Path <- paste(Data_Path,"Results/",Jurisdiction,"/",sep = "")

# Removes everything before the number
Step_One <- gsub(".*_","",list.files(paste(Data_Path,"/Distribution_Data/SAU_Distribution/",sep="")))

# Species List
Species_List <- gsub("\\..*","",Step_One)

# Set Spceies list
Exploited_Species <- fread(paste(Data_Path,"Distribution_Data/exploited_species_list.csv",sep="")) %>%
  filter(TaxonKey %in% Species_List)

# Step to run function for species not computed
Computed_Spp <- as.integer(gsub("\\_.*","",list.files(Results_Path)))

Exploited_Species <- Exploited_Species %>%
  filter(!TaxonKey %in% Computed_Spp)

# Gabriel's coordinate system
CoorG <- read.csv(paste(Data_Path,"Spatial_Data/coordinates_gab.csv",sep="")) %>%
  mutate(INDEX = seq(1,259200,1))

# For Function
Exploited_Species_List <- Exploited_Species$TaxonKey

# Load Jursidiction-dependant data

# Load neighbours data from previouse routine
Neighbours_Data <- read_excel(paste(Data_Path,"Spatial_Data/EEZ_Neighbour_List.xlsx", sep =""))

# Modifications have to be made if ran un Hall
# R<e9>union (Réunion) and C<f4>te d'Ivoire (Côte d'Ivoire)

# SAU relations between INDEX and Country's EEZs
EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))
EEZ_CellID <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/EEZ_CellID.xlsx",sep=""))
colnames(EEZ_CellID) <- c("EEZID","INDEX")

Index_Code <- EEZIDs_List %>% 
  left_join(EEZ_CellID) %>% 
  rename(Territory = Name)

# Creates dummy dataset for Non transboundary species
write.csv(tibble(), paste(Results_Path,"Non_Transboundary_Data.csv",sep=""), row.names = F)

# Number of cores to us 
n_cores <- detectCores()

# Just a warning for me not to forget
print(paste("You are running the model for",nrow(Exploited_Species),"Species at the",Jurisdiction,"level and will be saved at",Results_Path))
```

```{r Trans_Spp_Routine, eval = F, echo = F}

# Run model in parallel
system.time(
  Dis_Trans <- bind_rows(
    mclapply(
      Exploited_Species_List,
      FUN = EstTransIndex,
      Model = "All", # all data sources
      Neighbours = Neighbours_Data,
      Coord = CoorG,  # Gabriels coordinate system for read species dist
      Index_Code = Index_Code, 
      Save = "Y",  # For saving
      Jurisdiction_Type = Jurisdiction # For saving in proper path
    )
  )
)

# Data on time for the Beast with 30 cores
# user   system  elapsed 
# 8117.72  1991.91 10296.00 

# Data on time for the Beast with 32 cores
 #  user  system elapsed 
# 7831.10 1327.27 9261.48 
    
   
```

# Results

## Functions needed

### Function `GetTransResults`

This function simply reads in the files and import them all as on large d.f

```{r Fun_GetTransResults, eval = F}

GetTransResults=function(Spp){

  # Set the path for each file
  Distpath <- paste(Results_Path,"Trans_Results/",Spp,sep="")
  
  # Loads all files in a df
  Load_Data <- bind_rows(lapply(Distpath, FUN=fread))
  
  return(Load_Data)

}

```

### Function `CleanResults`

There are quite a few inconsistencies between the names of territories within the SAU shapefile, the distribution data and the UN database. The following function cleans up the names, some of them manually some of the automatic. It also removes the "transboundary nature" of those species shared by two territories that belong to the same nation (e.g. Brazil mainland and Brazil (Fernando de Noronha) or US Gulf of Mexico and US East coast). Finally, there is an annoying thing coding issue between MAC and Windows related to characters so I have to also fix for that, manually.

```{r funCleanResults, eval = F, echo = F}

# Requires Clean_sau_eez_fes

CleanResults <- function(Data){

# Clean out countries that share with their own borders (e.g. Brazil mainland and Brazil (Fernando de Noronha))
  Auto_Remove_Territories <- Data %>% 
    filter(!is.na(Territory),
           !is.na(Neighbour)) %>% 
    rename(FishingRegion=Territory) %>% 
    left_join(Clean_sau_eez_fes,
              by = "FishingRegion") %>% 
    select(TaxonKey,
           Territory= FishingRegion,
           FishingRegion=Neighbour, 
           Model_Index,
           Area_Index,
           CT_fishing_entity= fishing_entity) %>% 
    left_join(Clean_sau_eez_fes,
              by = "FishingRegion") %>% 
    select(1,2, 
           Neighbour = FishingRegion,
           Model_Index:CT_fishing_entity,
           NT_fishing_entity= fishing_entity,
           everything()) %>% 
    mutate(
      CT_fishing_entity = ifelse(is.na(CT_fishing_entity),paste(Territory),paste(CT_fishing_entity)),
      NT_fishing_entity = ifelse(is.na(NT_fishing_entity),paste(Neighbour),paste(NT_fishing_entity)),
      Same_Nation = ifelse(CT_fishing_entity==NT_fishing_entity,"Yes","No")
    )
  
  #### Manual removal of those left... 
  
  # List of territories to eliminate (No other neighobors but mainland)
  Islands_to_Remove <- c(
    "Brazil (Fernando de Noronha)",
    "Brazil (St Paul and St. Peter Archipelago)",
    "Hawaii Main Islands (USA)",
    "Hawaii Northwest Islands (USA)",
    "Juan Fernandez Islands (Chile)",
    "Kermadec Isl. (New Zealand)"
  )
  
  # Complete list of territories to remove from dataset (Including islands)
  Territories_to_Remove <- Data %>% 
    filter(
      Territory %in% Islands_to_Remove |
        Neighbour %in% Islands_to_Remove |
        Territory == "Balearic Island (Spain)" & Neighbour == "Spain (Mediterranean and Gulf of Cadiz)" |
        Territory == "British Virgin Isl. (UK)" & Neighbour == "Anguilla" |
        Neighbour == "British Virgin Isl. (UK)" & Territory == "Anguilla" |
        Territory == "Corsica (France)" & Neighbour == "France (Mediterranean)" |
        Neighbour == "Corsica (France)" & Territory == "France (Mediterranean)" |
        Territory == "Crete (Greece)" & Neighbour == "Grece" |
        Neighbour == "Crete (Greece)" & Territory == "Grece" |
        Territory == "Cyprus (North)" & Neighbour == "Cyprus (South)" |
        Neighbour == "Cyprus (North)" & Territory == "Cyprus (South)" |
        Territory == "Channel Isl. (UK)" & Neighbour == "United Kingdom" |
        Neighbour == "Channel Isl. (UK)" & Territory == "United Kingdom" |
        Territory == "Glorieuse Islands (France)" & Neighbour == "Mayotte (France)" |
        Neighbour == "Glorieuse Islands (France)" & Territory == "Mayotte (France)" |
        Territory == "Guam (USA)" & Neighbour == "Northern Marianas (USA)" |
        Neighbour == "Guam (USA)" & Territory == "Northern Marianas (USA)" |
        Territory == "Italy" & Neighbour == "Sardinia (Italy)" |
        Neighbour == "Italy" & Territory == "Sardinia (Italy)" |
        Territory == "Italy" & Neighbour == "Sicily (Italy)" |
        Neighbour == "Italy" & Territory == "Sicily (Italy)" |
        Territory == "Japan (Daito Islands)" & Neighbour == "Japan (main islands)"|
        Neighbour == "Japan (Daito Islands)" & Territory == "Japan (main islands)"|
        Territory == "Japan (Daito Islands)" & Neighbour == "Japan (Ogasawara Islands)"|
        Neighbour == "Japan (Daito Islands)" & Territory == "Japan (Ogasawara Islands)"|
        Territory == "Norway" & Neighbour == "Svalbard Isl. (Norway)" |
        Neighbour == "Norway" & Territory == "Svalbard Isl. (Norway)" |
        Territory == "Sicily (Italy)" & Neighbour == "Sardinia (Italy)" |
        Neighbour == "Sicily (Italy)" & Territory == "Sardinia (Italy)" |
        Territory == "South Africa (Atlantic Coast)" & Neighbour == "South Africa (Indian Ocean Coast)" |
        Neighbour == "South Africa (Atlantic Coast)" & Territory == "South Africa (Indian Ocean Coast)" |
        Territory == "USA (Alaska, Arctic)" & Neighbour == "USA (Alaska, Subarctic)" |
        Neighbour == "USA (Alaska, Arctic)" & Territory == "USA (Alaska, Subarctic)"
    ) %>%
    group_by(Territory,Neighbour) %>% 
    summarise(n())
  
  # Cleaned results 
  Clean_Results <- Auto_Remove_Territories %>% 
    anti_join(Territories_to_Remove,
              by = c("Territory","Neighbour")
    ) %>% 
    filter(Same_Nation == "No") %>% 
    select(-8,-9) %>% 
    # Fix coding issues between MAC and Windows
    mutate(
    Territory = gsub("Cura<e7>ao (Netherlands)","Curaçao (Netherlands)",Territory),
    Territory = gsub("C<f4>te d'Ivoire","Côte d'Ivoire",Territory),
    Territory = gsub("R<e9>union (France)","Réunion",Territory),
    Neighbour = gsub("Cura<e7>ao (Netherlands)","Curaçao (Netherlands)",Neighbour),
    Neighbour = gsub("C<f4>te d'Ivoire","Côte d'Ivoire",Neighbour),
    Neighbour = gsub(" R<e9>union (France)","Réunion",Neighbour)
    )
  
  return(Clean_Results)

}

# x <- Clean_Results(Discrete_Data)

```

## Load Results data

In here we load and cleaned the multiple external datasets requred to produce the manuscript figures 

```{r Load_Results_Data, eval = F}

# Set Jurisdiction to EEZ or RFMO
Jurisdiction <- "EEZ"

# Updates result's path for the jurisdiction
Results_Path <- paste(Results_Path,Jurisdiction,"/",sep="")

# Species list to get species names
Exploited_Species <- fread(paste(Data_Path,"Distribution_Data/exploited_species_list.csv",sep=""))
Spp_Clasification <- fread(paste(Data_Path,"Distribution_Data/SppTaxonName.csv",sep=""))


# Spatial Data needed to remove duplicates
sau_eez_fes <- fread(paste(Data_Path,"Spatial_Data/sau_eez_fes.csv",sep=""))

Clean_sau_eez_fes <- sau_eez_fes %>% 
  gather("Type","FishingRegion",2,4) %>% 
  left_join(sau_eez_fes,
            by = ("fishing_entity_id")
  ) %>% 
  group_by(FishingRegion,fishing_entity) %>% 
  summarise(n())

# UN Regions dataset
UN_Regions <- read.csv(paste(Data_Path,"Spatial_Data/UN_Regions.csv",sep=""), header = TRUE) %>% 
  group_by(Territory = Country.or.Area,
           georegion = Region.Name) %>% 
  summarise(n=n()) %>% #merge china's 3 rows
  select(-n) %>% 
  filter(Territory != "") %>%  # there are three rows with "developing" status as in, the code
  ungroup() %>% 
  # Change names to match SAU data and for shorter versions
  mutate(
    Territory = gsub("\\s*\\([^\\)]+\\)","",Territory),
    Territory = gsub("United Kingdom of Great Britain and Northern Ireland","United Kingdom",Territory),
    Territory = gsub( "United States of America", "USA",Territory),
    Territory = gsub("Democratic People's Republic of Korea", "Korea (North)",Territory),
    Territory = gsub("Republic of Korea", "Korea (South)",Territory),
    Territory = gsub("Iran (Islamic Republic of)", "Iran",Territory),
    Territory = gsub("Democratic Republic of the Congo", "Congo (ex-Zaire)",Territory),
    # Territory = gsub("Congo", "Congo, R. of",Territory),
    Territory = gsub("United Republic of Tanzania", "Tanzania",Territory),
    Territory = gsub("Cabo Verde", "Cape Verde",Territory),
    Territory = gsub("Timor-Leste", "Timor Leste",Territory),
    Territory = gsub(" and ", " & ",Territory),
    # Territory = gsub("Puerto Rico (USA)", "Puerto Rico",Territory),
    Territory = gsub("Taiwan", "Taiwan (China)",Territory)
  )

# Manually change congo
UN_Regions[52,1] <- "Congo, R. of"

# Load Land shapefile
path_world_land <- paste(Data_Path,"Spatial_Data/ne_50m_admin_0_countries",sep="")

# The File
fnam_world_land <- "ne_50m_admin_0_countries.shp"

# Load it!
World_land_sf <- st_read(dsn = path_world_land,
                         layer =file_path_sans_ext(fnam_world_land)) %>% 
  rename(Territory = NAME) 

# head(World_land_sf)

# Load SAU shapefile name and paths

# The path
path_world <- paste(Data_Path,"Spatial_Data/SAU_Shapefile/",sep="")

# The File
fnam_world <- "SAUEEZ_July2015.shp"

# Load it!
World_sf <- st_read(dsn = path_world,
                    layer =file_path_sans_ext(fnam_world)) %>% 
  rename(Territory = Name)

# ---------------------------- #
# Transboundary Results ####
# ---------------------------- #

# Read Sau Catch Data
Sau_Catch_Data <- fread(paste(Data_Path,"Distribution_Data/Sau_Catch_Data.csv", sep ="")) %>% 
  filter(!is.na(Territory))

# Read Sau Value Data (Thank you Tim!)
Sau_Revenue_Data <- fread(paste(Data_Path,"Distribution_Data/sau_catch_value_country_taxon_JEPA.csv", sep ="")) %>% 
  group_by(fishing_entity_id,TaxonKey=taxon_key) %>% 
  summarise(Mean_Value = mean(value,na.rm=T))

# Read Species Status Data (Sub-routine Species Status)
Status_Data <- fread(paste(Data_Path,"Distribution_Data/Species_Status.csv", sep =""))

# List of species
Spp <- list.files(paste(Results_Path,"Trans_Results/",sep=""))[-829]

# Load and clean transboundary results
Results_Trans <- GetTransResults(Spp)

# Clean results susing function CleanResultsfun
Clean_Results_Trans <- CleanResults(Results_Trans)

# Load and clean Discrete results
Non_Transboundary_Data <- fread(paste(Results_Path,"/Non_Transboundary_Data.csv",sep="")) %>% 
  filter(!is.na(TaxonKey)) %>% 
  select(2:3)

```

## Determine Tresholds

Determine transboundary stocks and countries based on selected trsholds. We created two tresholds (levels of uncertanty), in here we can chose which level we wanna work with.

```{r Results_Tresholds, eval = F, echo = F}

#### Select Tresholds ###

# Area Index
Min_AI <- 0.25 # Min area index
Max_AI <- 1-Min_AI # Max Area Index

# Model Index
MI <- 100 # Model Index

####_____End Select Tresholds_______ ###


#### Determine transboundary and non-transboundary species and nations

Tresholded_T_Data <- Clean_Results_Trans %>% 
  filter(
    Area_Index >= Min_AI,
    Area_Index <= Max_AI,
    Model_Index >= MI
  )

### Non-transboundary Tresh 1
Clean_Non_Transboundary_Data <- Non_Transboundary_Data %>% 
  rename(eez_name = Territory) %>% 
  left_join(sau_eez_fes) %>% 
  group_by(Territory = fishing_entity) %>% 
  summarise(value = length(unique(TaxonKey)),
            Taxons = paste(unique(TaxonKey),collapse = ";"))

## Determine as Trans. those species that are both trans and discrete for a nation (Tresh 2 and 3)
Tresholded_D_Data <- Clean_Results_Trans %>% 
  filter(Model_Index == MI) %>% 
  mutate(Species_Type = ifelse(Area_Index > Max_AI,"Discrete",
                               ifelse(Area_Index < Min_AI,NA,
                                      "Transboundary"))
  ) %>% 
  filter(!is.na(Species_Type)) %>% 
  group_by(CT_fishing_entity,Species_Type,TaxonKey) %>%
  summarise(n=n()) %>%
  spread(Species_Type,n) %>% 
  mutate(Discrete = ifelse(!is.na(Discrete) & !is.na(Transboundary),NA,Discrete)) %>% 
  gather("Species_Type","value", Discrete:Transboundary) %>% 
  filter(!is.na(value),
         Species_Type == "Discrete") %>% 
  group_by(Territory = CT_fishing_entity) %>% 
  summarise(value = length(unique(TaxonKey)),
            Taxons = paste(unique(TaxonKey),collapse = ";")) %>% 
  #  Include discrete species of Trsh. 1
  bind_rows(Clean_Non_Transboundary_Data) %>%
  # Data cleaning (group by territory and include georegions for plot)
  rename(FishingRegion=Territory) %>% 
  left_join(Clean_sau_eez_fes) %>% 
  group_by(Territory = fishing_entity)
  
```

## Results per Territory

Determine the number of species per territory

```{r Data_per_Territory, eval = F, echo = F}

# Data per Territory
Transboundary_Spp <- Tresholded_T_Data %>% 
  group_by(Territory) %>% 
  summarise(
    n_trans_spp = length(unique(TaxonKey)),
    n_Neighbours = length(unique(Neighbour)),
    Trans_Rate = n_trans_spp/n_Neighbours
  ) %>% 
  mutate(
    Bins = cut(n_trans_spp,breaks = 4),
    Bins_Plot = cut(n_trans_spp,breaks = 4,
                    labels = c('super low', 'low', 'high','super high'))
  )

# Number of Transboundary Species
Total_trans_n <- Clean_Results_Trans %>% 
  filter(
    Area_Index >= Min_AI,
    Area_Index <= Max_AI,
    Model_Index >= MI
  ) 

length(unique(Total_trans_n$TaxonKey)) #674 spp



# Get Catch data for mapping (Currently not used)

# Catch_Country <- Sau_Catch_Data %>% 
#   group_by(FishingRegion=Territory) %>% 
#   summarise(Total_Catch = round(sum(Mean_Catch,na.rm=T),2)) %>% 
#   filter(!(is.na(FishingRegion))) %>% 
#   left_join(Clean_sau_eez_fes) %>% 
#   group_by(Territory = fishing_entity) %>% 
#   summarise(Total_Catch = sum(Total_Catch,na.rm=T)) %>% 
#   mutate(Territory = gsub("USA","United States of America",Territory))

# Get Catch and Revenue data for mapping 

Tresholded_T_Data_x <- Tresholded_T_Data %>% 
  select(TaxonKey, Territory=CT_fishing_entity)

Revenue_Country <- sau_eez_fes %>% 
  group_by(fishing_entity_id, Territory = fishing_entity) %>% 
  summarise(n=n()) %>% 
  select(-n) %>% 
  left_join(Tresholded_T_Data_x) %>% 
  left_join(Sau_Revenue_Data) %>% 
  group_by(Territory) %>% 
  summarise(Total_USD = (sum(Mean_Value,na.rm=T))/1000000) %>% # Million of USD
  mutate(Territory = ifelse(Territory == "USA","United States of America",Territory),
         Bins = cut(Total_USD,breaks = 4),
         Bins_Plot = cut(Total_USD,breaks = 4,
                         labels = c('super low', 'low','high','super high'))
  ) %>% 
  filter(Total_USD > 0)
```

### Map of Transboundary Species

Produce the map of transboundary species within each EEZ and the value in catch/revenue within each country

```{r Territory_Map, eval =F, echo =F}

# Transboundary Species shapefile
World_sf_si <- World_sf %>%
  st_transform(crs = 4326) %>% # 4326
  st_simplify(preserveTopology = TRUE, dTolerance = 0.1) %>%
  left_join(Transboundary_Spp, by ="Territory") 

# Total catch/Revenue shapefile
World_sf_si_land <- World_land_sf %>%
  st_transform(crs = 4326) %>% # 4326
  st_simplify(preserveTopology = TRUE, dTolerance = 0.1) %>% 
  left_join(Revenue_Country, by ="Territory")

# Get the NA's to be grey
Grey_land <- World_sf_si_land %>% 
  filter(is.na(Bins))

# Make map
Plot <- ggplot() +
  geom_sf(data = World_sf_si_land,aes(fill = reorder(Bins_Plot,Total_USD)), colour = "grey80",size = 0.1) +
  geom_sf(data = World_sf_si,aes(fill =  reorder(Bins_Plot,n_trans_spp)),colour = "grey20", size = 0.1) + # n_trans_spp or Bins
  geom_sf(data = Grey_land,aes(fill = Bins),fill = "grey80", colour = "grey50",size = 0.1) + # n_trans_spp or Bins
  # scale_fill_gradientn(colours = pal,
  #                      na.value = "white") +
  # scale_fill_manual(values = c(rev(wes_palette(n = 4, name = "Darjeeling1")),
  # rev(wes_palette(n = 4, name = "Darjeeling2"))
  # ),
  # na.value = "white"
  # ) +
  scale_fill_manual("",values = c("#5BBCD6",#"#5BBCD6", # blue
                                  "#00A08A",#"#00A08A", #green
                                  "#F2AD00",#"#F2AD00", # Yellow
                                  # "#F98400",#"#F98400", #Orange
                                  "#FF0000"#,"#FF0000" #Red
  ),
  na.value = "white"
  ) +
  # scale_fill_manual(values = rev(wes_palette(n = 5, name = "Darjeeling1")),
  #                    na.value = "white"
  # ) +
  ggtheme_map()

Plot_Name <- paste("New_100_25_Bins_Value.png", sep = "") 

ggsave(Plot_Name,
       plot = Plot,
       width = 16,
       height = 8,
       units = "in",
       path = Figures_Path
)

```

### OHI-inspired Circular plot for Territories

```{r Circular_Country_Data, eval = F, echo = F}

# -------------------------- #
# Transboundary data
# -------------------------- #

Countries_Data_Plot <- Tresholded_T_Data %>% 
  group_by(Territory = CT_fishing_entity) %>% 
  summarise(value = length(unique(TaxonKey))) %>% 
  left_join(UN_Regions, by ="Territory") %>%
  mutate(group = ifelse(is.na(georegion),"Other",paste(georegion))) %>% 
  rename(FishingRegion=Territory) %>% 
  left_join(Clean_sau_eez_fes) %>% 
  group_by(individual = fishing_entity,group) %>% 
  summarise(Total_trans = sum(value,na.rm=T)) %>% 
  mutate(value = ifelse(Total_trans > 100,100,Total_trans)) %>% 
  filter(!is.na(individual)) %>% 
  select(individual,group,value) %>% 
  arrange(group,value)

# -------------------------- #
# Discrete data
# -------------------------- #

Discrete_Data_Plot <- Tresholded_D_Data %>% 
  summarise(value =sum(value,na.rm = T)*-1) %>% # Multyply them by -1 so they appear negative on plot
  mutate(value = ifelse(value <= -100,-100,value)) %>% 
  left_join(UN_Regions, by ="Territory") %>%
  mutate(group = ifelse(is.na(georegion),"Other",paste(georegion))) %>% 
  filter(!is.na(Territory)) %>% 
  select(individual = Territory,
         group,
         value)

# -------------------------- #
# Stock status Data
# -------------------------- #

Status_Data_Plot <- Tresholded_T_Data %>% 
  # mutate(TaxonKey = as.character(TaxonKey)) %>% 
  # rename(Territory = CT_fishing_entity) %>% 
  left_join(Status_Data, 
            by =c("Territory","TaxonKey")
  ) %>%
  mutate(Status = ifelse(is.na(Status),"No Status",Status)) %>% 
  group_by(Territory,Status) %>% 
  summarise(value = length(unique(TaxonKey))) %>% 
  left_join(UN_Regions, by ="Territory") %>%
  mutate(Georegion = ifelse(is.na(georegion),"Other",paste(georegion))) %>% 
  rename(FishingRegion=Territory) %>% 
  left_join(Clean_sau_eez_fes) %>% 
  group_by(individual = fishing_entity,
           group = Georegion,
           observation = Status) %>% 
  summarise(Total_trans = sum(value,na.rm=T)) %>% 
  mutate(value = ifelse(Total_trans > 100,100,Total_trans)) %>% 
  filter(!is.na(individual)) %>% 
  select(individual,observation,group,value) %>% 
  arrange(group,value) %>% 
  mutate(value = ifelse(observation %in% c("Collapsed","Over Exploited"),value*-1,value))

# Include possible missing countries in bothe datasets
Countries_Data_Plot <- Discrete_Data_Plot %>% 
  anti_join(Countries_Data_Plot,
            by = c("individual","group")) %>% 
  mutate(Total_Discrete = 0) %>% 
  bind_rows(Countries_Data_Plot)

Discrete_Data_Plot <- Countries_Data_Plot %>% 
  anti_join(Discrete_Data_Plot,
            by = c("individual","group")) %>% 
  mutate(value = 0) %>% 
  bind_rows(Discrete_Data_Plot)

```

```{r}

data <- data.frame(
  individual=paste( "Mister ", seq(1,60), sep=""),
  group=c( rep('A', 10), rep('B', 30), rep('C', 14), rep('D', 6)) ,
  value1=sample( seq(10,100), 60, replace=T),
  value2=sample( seq(10,100), 60, replace=T),
  value3=sample( seq(10,100), 60, replace=T)
)
 
# Transform data in a tidy format (long format)
data <- data %>% gather(key = "observation", value="value", -c(1,2)) 
 
# Set a number of 'empty bar' to add at the end of each group
empty_bar <- 2
nObsType <- nlevels(as.factor(data$observation))
to_add <- data.frame( matrix(NA, empty_bar*nlevels(data$group)*nObsType, ncol(data)) )
colnames(to_add) <- colnames(data)
to_add$group <- rep(levels(data$group), each=empty_bar*nObsType )
data <- rbind(data, to_add)
data <- data %>% arrange(group, individual)
data$id <- rep( seq(1, nrow(data)/nObsType) , each=nObsType)
 
# Get the name and the y position of each label
label_data <- data %>% group_by(id, individual) %>% summarize(tot=sum(value))
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)
 
# prepare a data frame for base lines
base_data <- data %>% 
  group_by(group) %>% 
  summarize(start=min(id), end=max(id) - empty_bar) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)))
 
# prepare a data frame for grid (scales)
grid_data <- base_data
grid_data$end <- grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1
grid_data$start <- grid_data$start - 1
grid_data <- grid_data[-1,]
 
# Make the plot
ggplot(data) +      
  
  # Add the stacked bar
  geom_bar(aes(x=as.factor(id), y=value, fill=observation), stat="identity", alpha=0.5) +
  # scale_fill_viridis(discrete=TRUE) +
  
  # Add a val=100/75/50/25 lines. I do it at the beginning to make sur barplots are OVER it.
  geom_segment(data=grid_data, aes(x = end, y = 0, xend = start, yend = 0), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 50, xend = start, yend = 50), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 100, xend = start, yend = 100), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 150, xend = start, yend = 150), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 200, xend = start, yend = 200), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  
  # Add text showing the value of each 100/75/50/25 lines
  ggplot2::annotate("text", x = rep(max(data$id),5), y = c(0, 50, 100, 150, 200), label = c("0", "50", "100", "150", "200") , color="grey", size=6 , angle=0, fontface="bold", hjust=1) +
  
  ylim(-150,max(label_data$tot, na.rm=T)) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-1,4), "cm") 
  ) +
  coord_polar() +
  
  # Add labels on top of each bar
  geom_text(data=label_data, aes(x=id, y=tot+10, label=individual, hjust=hjust), color="black", fontface="bold",alpha=0.6, size=5, angle= label_data$angle, inherit.aes = FALSE ) +
  
  # Add base line information
  geom_segment(data=base_data, aes(x = start, y = -5, xend = end, yend = -5), colour = "black", alpha=0.8, size=0.6 , inherit.aes = FALSE )  +
  geom_text(data=base_data, aes(x = title, y = -18, label=group), hjust=c(1,1,0,0), colour = "black", alpha=0.8, size=4, fontface="bold", inherit.aes = FALSE)


```

```{r Territories_Circluar_Plot, eval = F, echo = T}

# -------------------------- #
# Data manipulation for plot
# -------------------------- #

# Set a number of 'empty bar' to add at the end of each Georegion
Char <- as.factor(Status_Data_Plot$group) # Set groups to factors


##### COPY PASTE

# Transform data in a tidy format (long format)
data <- Status_Data_Plot
 
# Set a number of 'empty bar' to add at the end of each group
empty_bar <- 5
nObsType <- nlevels(as.factor(data$observation))
to_add <- data.frame( matrix(NA, empty_bar*nlevels(Char)*nObsType, ncol(data)) )
colnames(to_add) <- colnames(data)
to_add$group <- rep(levels(Char), each=empty_bar*nObsType)
# to_add$individual <- rep(letters[1:6], each=empty_bar*nObsType)
data <- bind_rows(data, to_add)
data <- data %>% arrange(group, individual) %>% rowwise() %>%  mutate(id = as.numeric(as.factor(individual)))
data$id <- as.numeric(as.factor(data$individual))
 

# Get the name and the y position of each label
label_data <- data %>% group_by(id, individual) %>% summarize(tot=sum(value))
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)

# prepare a data frame for base lines
base_data <-  data %>% 
  group_by(group) %>% 
  summarize(start=min(id,na.rm=T), 
            end=max(id,na.rm=T) - empty_bar) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)))
 
# prepare a data frame for grid (scales)
grid_data <- base_data
grid_data$end <- grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1
grid_data$start <- grid_data$start - 1
grid_data <- grid_data[-1,]

data <- data %>% 
  ungroup() %>% 
  mutate(individual = ifelse(is.na(observation),NA,observation))


ggplot(data) + 
  # Add the stacked bar
  geom_bar(aes(x=as.factor(id), y=value, fill=observation,group=group), stat="identity", alpha=0.5) +
  scale_fill_manual("Catch Trend",
                    values = c(wes_palette(n = 5, name = "Darjeeling1"),
                               wes_palette(n = 1, name = "Darjeeling2")
                    ),
                    na.value = "white"
  ) +
  
  # Add a val=100/75/50/25 lines. I do it at the beginning to make sur barplots are OVER it.
  geom_segment(data=grid_data, aes(x = end, y = 0, xend = start, yend = 0), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 50, xend = start, yend = 50), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 100, xend = start, yend = 100), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 150, xend = start, yend = 150), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 200, xend = start, yend = 200), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  
  # Add text showing the value of each 100/75/50/25 lines
  ggplot2::annotate("text", x = rep(max(data$id),5), y = c(0, 50, 100, 150, 200), label = c("0", "50", "100", "150", "200") , color="grey", size=6 , angle=0, fontface="bold", hjust=1) +
  
  ylim(-150,max(label_data$tot, na.rm=T)) +
  theme_minimal() +
  theme(
    legend.position = "right",
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-1,4), "cm") 
  ) +
  coord_polar() +
  
  # Add labels on top of each bar
  geom_text(data=label_data, aes(x=id, y=max(tot,na.rm=T), label=individual, hjust=hjust), color="black", fontface="bold",alpha=0.6, size=2, angle= label_data$angle, inherit.aes = FALSE ) +
  
  # Add base line information
  geom_segment(data=base_data, aes(x = start, y = -5, xend = end, yend = -5), colour = "black", alpha=0.8, size=0.6 , inherit.aes = FALSE )  +
  geom_text(data=base_data, aes(x = title, y = -18, label=group), hjust=c(1,1,1,0,0,0), colour = "black", alpha=0.8, size=4, fontface="bold", inherit.aes = FALSE)



#### END COPY PASTE


empty_bar <- 5
nObsType <- nlevels(as.factor(Status_Data_Plot$observation))
to_add <- data.frame( matrix(NA, empty_bar*nlevels(Char)*nObsType, ncol(Status_Data_Plot)) )
colnames(to_add) <- colnames(Status_Data_Plot)
to_add$group <- rep(levels(Char), each=empty_bar*nObsType)
Status_Data_Plot <- bind_rows(Status_Data_Plot, to_add)
Status_Data_Plot <- Status_Data_Plot %>% arrange(group, individual)
# Status_Data_Plot$id <- c(rep(seq(1,round(nrow(Status_Data_Plot)/nObsType)) , each=nObsType),128)
Status_Data_Plot$id <- as.numeric(as.factor(Status_Data_Plot$individual))




# Get the name and the y position of each label

# Top n of each group label
Top_Countries <- Status_Data_Plot %>% 
  group_by(group) %>% 
  top_n(5,value)

# Create labels for all but top 5
# Get the name and the y position of each label

label_data <- Status_Data_Plot %>% 
  group_by(id, individual) %>% 
  summarize(tot=sum(value))

label_data <- Status_Data_Plot 
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)


# Remove top 5
label_data_rest <- label_data %>% 
  filter(!individual %in% Top_Countries$individual)

# Create labels for top 5
Top_label_data <- label_data %>% 
  filter(individual %in% Top_Countries$individual)

# prepare a data frame for base lines
base_data <- Status_Data_Plot %>% 
  group_by(group) %>% 
  summarize(start=min(id,na.rm=T), 
            end=max(id,na.rm=T) - empty_bar, 
            median = median(value, na.rm = T)
            ) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)))


# prepare a data frame for grid (scales)
grid_data <- base_data
grid_data$end <- grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1
grid_data$start <- grid_data$start - 1
# grid_data[1,2] <- 5 # Manually include Africa for the median
# grid_data[1,3] <- 1

# Median data
median_data <- grid_data %>% 
  mutate_at(vars(start,end),
            .funs = as.numeric)
 

# -------------------------- #
# Make the plot
# -------------------------- #


# Global Variables
Seq_axis <- seq(0,100,20)
Plot_Limit <- max(Status_Data_Plot$value,na.rm=T)
Plot_Limit_Low <- -50
Ticks_Color <- "grey50"

ggplot(Status_Data_Plot) +      
  
  # Add the stacked bar
  geom_bar(aes(x=as.factor(id), y=value, fill=observation), stat="identity", alpha=0.5) +
  # scale_fill_viridis(discrete=TRUE) +
  
  # Add a val=100/75/50/25 lines. I do it at the beginning to make sur barplots are OVER it.
  geom_segment(data=grid_data, aes(x = end, y = 0, xend = start, yend = 0), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 50, xend = start, yend = 50), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 100, xend = start, yend = 100), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 150, xend = start, yend = 150), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 200, xend = start, yend = 200), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  
  # Add text showing the value of each 100/75/50/25 lines
  ggplot2::annotate("text", x = rep(max(Status_Data_Plot$id,na.rm=T),5), y = c(0, 50, 100, 150, 200), label = c("0", "50", "100", "150", "200") , color="grey", size=6 , angle=0, fontface="bold", hjust=1) +
  
  ylim(-150,max(label_data$value, na.rm=T)) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-1,4), "cm") 
  ) +
  coord_polar() +
  
  # Add labels on top of each bar
  geom_text(data=label_data, aes(x=id, y=value+10, label=individual, hjust=hjust), color="black", fontface="bold",alpha=0.6, size=5, angle= label_data$angle, inherit.aes = FALSE ) +
  
  # Add base line information
  geom_segment(data=base_data, aes(x = start, y = -5, xend = end, yend = -5), colour = "black", alpha=0.8, size=0.6 , inherit.aes = FALSE )  +
  geom_text(data=base_data, aes(x = title, y = -18, label=group), hjust=c(1,1,0,0,1,1), colour = "black", alpha=0.8, size=4, fontface="bold", inherit.aes = FALSE)
















# Base plot
ggplot(Status_Data_Plot,
       aes(x=as.factor(id), 
           y=value,
           fill=observation)
) +       # Note that id is a factor. If x is numeric, there is some space between the first bar
  geom_bar(aes(x=as.factor(id),
               y=value,
               fill=observation),
           stat="identity",
           alpha=0.5) +
  # Add a val=100/75/50/25 lines. I do it at the beginning to make sur barplots are OVER it.
  geom_segment(data=grid_data, aes(x = end, y = 100, xend = start, yend = 100), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 80, xend = start, yend = 80), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 60, xend = start, yend = 60), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 40, xend = start, yend = 40), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 20, xend = start, yend = 20), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 0, xend = start, yend = 0), colour = "black", alpha=0, size=0.3 , inherit.aes = FALSE ) +
  # Add median lines for each gropup
  # geom_segment(data=median_data,
  #              aes(x = end,
  #                  y = median,
  #                  xend = start+5, 
  #                  yend = median,
  #                  colour = group),
  #              alpha=1,
  #              size=0.5 , 
  #              inherit.aes = FALSE ) +
  # Add text showing the value of each line
  annotate("text", 
           x = rep(max(Status_Data_Plot$id),length(Seq_axis)),
           y = Seq_axis,
           label = c("<-100",as.character(Seq_axis)[2:(length(Seq_axis)-1)],">100"),
           color = Ticks_Color, 
           size= 4, 
           angle = 0, 
           # fontface="bold",
           hjust=1) +
  ylim(-150,max(label_data$value, na.rm=T)) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-1,4), "cm") 
  ) +
  coord_polar() +
  #Country labels
  geom_text(data=label_data_rest,
            aes(x=id,
                y=Plot_Limit,
                label=individual,
                hjust=hjust), 
            color="black",
            # fontface="bold",
            alpha=1,
            size=2.5,
            angle= label_data_rest$angle,
            inherit.aes = FALSE) +
  # Bold top 3 
  geom_text(data=Top_label_data,
            aes(x=id, y=Plot_Limit,
                label=individual,
                hjust=hjust), 
            color="black",
            fontface="bold",
            alpha=1,
            size=2.5,
            angle= Top_label_data$angle,
            inherit.aes = FALSE) +
  # Add base line information
  geom_segment(data=base_data, 
               aes(x = start, 
                   y = 0, 
                   xend = end, 
                   yend = 0
                   ), 
               colour = "black",
               alpha=0.8, 
               size=0.6 , 
               inherit.aes = FALSE) +
  ylim(Plot_Limit_Low,Plot_Limit) + # sets the circle the first value the central the last value how wide
  theme_minimal() +
  coord_polar()
  theme(
    # legend.position = c(0.5,0.5),
    # legend.position = "",
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-1,4), "cm") 
  ) +
  coord_polar() + 
  scale_fill_manual("Continent",
                    values = c(wes_palette(n = 5, name = "Darjeeling1"),
                               wes_palette(n = 4, name = "Darjeeling2"),
                               "black","grey","blue"
                    ),
                    na.value = "white"
  ) +
  scale_colour_manual("Continent",
                      values = c(wes_palette(n = 5, name = "Darjeeling1"),
                                 wes_palette(n = 4, name = "Darjeeling2"),
                                 "black","grey","blue"
                      ),
                      na.value = "white")

# Save plot

ggsave(
    plot = last_plot(),
    width = 12,
    height = 12,
    units = "in",
    filename = "Territory_circular_both.png",
    path = "/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Figures/"
  )
 

```

## Analysis per Species

Create figures that are based in species (e.g. number of countries each species has)

```{r Circular_Spp_Data, eval = F, echo =F}

# Number of countries shared by each Species
Species_Trans <- Tresholded_T_Data %>% 
  group_by(TaxonKey) %>% 
  summarise(
    n_countries = length(unique(Territory))
  ) %>% 
  left_join(Exploited_Species) %>%
  left_join(Spp_Clasification)

# hist(Species_Trans$n_countries)

# Use rfishbase to get species environment
Species_list <- Species_Trans %>% 
  mutate(scientific_name = paste(Genus,Species)) %>% 
  pull(scientific_name)

Species_environ_list <- rbind(species(Species_list, #species from rfishbase package
                                      fields = species_fields$habitat[4])
) %>% 
  mutate(scientific_name = Species_list)

Species_Data <- Tresholded_T_Data %>% 
  group_by(TaxonKey) %>% 
  summarise(n_trans_spp = length(unique(Territory))) %>% 
  left_join(Exploited_Species) %>%
  rename(scientific_name = TaxonName) %>% 
  left_join(Species_environ_list) %>%
  mutate(DemersPelag = ifelse(is.na(DemersPelag),"Other",paste(DemersPelag)),
         n_trans_spp = ifelse(n_trans_spp > 100, 100, n_trans_spp)) %>% 
  select(individual=scientific_name,
         value = n_trans_spp,
         group = DemersPelag) %>% 
  arrange(group,value) %>% 
  filter(value > 20)  # remove all species under 20 (way too many to plot!)

```

### OHI-inspired Circular plot Species

```{r species_circluar_plot, eval = F, echo = T}

Median_trans <- median(Species_Data$value)
# hist(Species_Data$value)
# unique(Species_Data$group)

# Set a number of 'empty bar' to add at the end of each group
Char <- as.factor(Species_Data$group)
empty_bar <- 2
to_add <- data.frame( matrix(NA, empty_bar*nlevels(Char), ncol(Species_Data)) )
colnames(to_add) <- colnames(Species_Data)
to_add$group <- rep(levels(Char), each=empty_bar)
Species_Data <- rbind(Species_Data, to_add)
Species_Data <- Species_Data %>% arrange(group,value)
Species_Data$id <- seq(1, nrow(Species_Data))

# Get the name and the y position of each label

# Create labels for all but top 5
label_data <- Countries_Data 
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)

# Get the name and the y position of each label
# Top n of each group label
Top_spp <- Species_Data %>% 
  group_by(group) %>% 
  top_n(5,value)

# Create labels for all but top 5
label_data <- Species_Data
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)

# Remove top 5
label_data_rest <- label_data %>% 
  filter(!individual %in% Top_spp$individual)

# Create labels for top 5
Top_label_data <- label_data %>% 
  filter(individual %in% Top_spp$individual)


# prepare a data frame for base lines
base_data <- Species_Data %>% 
  group_by(group) %>% 
  summarize(start=min(id), 
            end=max(id) - empty_bar, 
            median = median(value, na.rm = T)
            ) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)))


# prepare a data frame for grid (scales)
grid_data <- base_data
grid_data$end <- grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1
grid_data$start <- grid_data$start - 1
# grid_data <- grid_data[-1,]
grid_data[1,2] <- 5 # Manually include bathydemerssal
grid_data[1,3] <- 1 
 

# Median data
median_data <- grid_data %>% 
  mutate_at(vars(start,end),
            .funs = as.numeric)

Seq_axis_spp <- seq(20,100,20)
Plot_Limit <- max(Species_Data$value,na.rm=T)

### ------------------- ###
# Make the plot
### ------------------- ###
ggplot(Species_Data, 
       aes(x=as.factor(id), 
           y=value,
           fill=group)
       ) +       # Note that id is a factor. If x is numeric, there is some space between the first bar
  geom_bar(aes(x=as.factor(id),
               y=value,
               fill=group),
           stat="identity",
           alpha=0.5) +
  # Add a val=100/75/50/25 lines. I do it at the beginning to make sur barplots are OVER it.
  geom_segment(data=grid_data, 
               aes(x = end, y = 100, xend = start, yend = 100), 
               colour = Ticks_Color, alpha=1, size=0.3, inherit.aes = FALSE) +
  geom_segment(data=grid_data,
               aes(x = end, y = 80, xend = start, yend = 80),  
               colour = Ticks_Color, alpha=1, size=0.3, inherit.aes = FALSE) +
  geom_segment(data=grid_data, 
               aes(x = end, y = 60, xend = start, yend = 60),  
               colour = Ticks_Color, alpha=1, size=0.3, inherit.aes = FALSE) +
  geom_segment(data=grid_data, 
               aes(x = end, y = 40, xend = start, yend = 40),  
               colour = Ticks_Color, alpha=1, size=0.3, inherit.aes = FALSE) +
  geom_segment(data=grid_data, 
               aes(x = end, y = 20, xend = start, yend = 20), 
               colour = Ticks_Color, alpha=1, size=0.3, inherit.aes = FALSE) +
  # Add median lines for each gropup
  geom_segment(data=median_data, 
               aes(x = end, y = median, xend = start+5, yend = median, colour = group),
               alpha=1, size=0.5 , inherit.aes = FALSE) +
  # Add text showing the value of each line
  annotate("text", 
           x = rep(max(Species_Data$id),5),
           y = Seq_axis_spp,
           label = c(Seq_axis_spp[-5],">100"),
           color=Ticks_Color, 
           size=3, 
           angle=0, 
           fontface="bold",
           hjust=1) +
  geom_bar(aes(x=as.factor(id),
               y=value,
               fill=group),
           stat="identity",
           alpha=0.5) +
  geom_text(data=label_data_rest,
            aes(x=id, y=101,
                label=individual,
                hjust=hjust), 
            color="black",
            fontface="italic",
            alpha=1,
            size=2.5,
            angle= label_data_rest$angle,
            inherit.aes = FALSE) +
  # Bold top 3 
  geom_text(data=Top_label_data,
            aes(x=id, y=101,
                label=individual,
                hjust=hjust), 
            color="black",
            fontface="bold.italic",
            alpha=1,
            size=2.5,
            angle= Top_label_data$angle,
            inherit.aes = FALSE) +
  # Add base line information
  geom_segment(data=base_data, 
               aes(x = start, 
                   y = -5, 
                   xend = end, 
                   yend = -5
               ), 
               colour = "black",
               alpha=0.8, 
               size=0.6 , 
               inherit.aes = FALSE) +
  ylim(-100,110) + # sets the circle the first value the central the last value how wide
  theme_minimal() +
  theme(
    legend.position = c(0.5,0.5),
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-1,4), "cm") 
  ) +
  coord_polar() + 
  scale_fill_manual("Ecosystem Preference",
                    values = c(wes_palette(n = 4, name = "GrandBudapest1"),
                               wes_palette(n = 4, name = "GrandBudapest2")
                    ),
                    na.value = "white"
  ) +
  scale_colour_manual("Ecosystem Preference",
                      values = c(wes_palette(n = 4, name = "GrandBudapest1"),
                                 wes_palette(n = 4, name = "GrandBudapest2")
                      ),
                      na.value = "white"
  )

ggsave(
  plot = last_plot(),
  width = 12,
  height = 12,
  units = "in",
  filename = "Species_circular_over20.png",
  path = "/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Figures/"
)
 
```

### Species status (SAU methods)

Note that (n), the number of ‘stocks’ is defined as a time series of a given species, genus or family (higher and pooled groups have been excluded) for which the first and last reported landings are at least 10 years apart, for which there are at least 5 years of consecutive catches and for which the catch in a given area is at least 1000 tonnes.

 1) The first and last reported landings are at least ten years apart;

2) There are at least five years of consecutive catches; and

3) The catch in a particular area (LME) is at least 1,000 tonnes.

Once those tresholds are met, the status of the species is determined as follows:

- Rebuilding (Recovering)	Year of landing > year of post-max. min. landing AND post-max. min. landing < 10% of max. landing AND landing is 10-50% of max. landing
- Developing	Year of landing < year of max. landing AND landing is < or = 50% of max. landing OR year of max. landing = final year of landing
- Exploited	Landing > 50% of max. landing
- Over exploited	Year of landing > year of max. landing AND landing is between 10-50% of max. landing
- Collapsed	Year of landing > year of max. landing AND landing is < 10% of max. landing

*Notes* = 3 years average mean


```{r Species_Status, eval = T, echo =F}

CoorG <- read.csv(paste(Data_Path,"Spatial_Data/coordinates_gab.csv",sep="")) %>%
  mutate(INDEX = seq(1,259200,1))

# SAU relations between INDEX and Country's EEZs
EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))
EEZ_CellID <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/EEZ_CellID.xlsx",sep=""))
colnames(EEZ_CellID) <- c("EEZID","INDEX")

Index_Code <- EEZIDs_List %>% 
  left_join(EEZ_CellID) %>% 
  rename(Territory = Name)


Spp <- GetSppDist(600004, Model = "SAU_C", Coord = CoorG)

Data <- Spp %>% 
  gather("Year","Value",CATCH.1:CATCH.65) %>% 
  arrange(INDEX) %>% 
  mutate(Year = rep(seq(1951,2014,1),263250)) %>% 
  left_join(Index_Code) %>% 
  filter(!is.na(EEZID),
         Value > 0) %>% 
  group_by(Species,Year,EEZID,Territory) %>% # Total catch per country
  summarise(Total_Catch = sum(Value,na.rm=T)) %>% 
  group_by(Species,Territory,EEZID,Year) %>% 
  mutate(RMean = rollmean(x = Total_Catch, 5, align = "right", fill = Total_Catch)) %>% 
  group_by(Species,Territory,EEZID)

# head(Data)

# Tresholds to evaluate stocks if these are not met, then soecies status = "No Status"
 Tresholds <- Data %>% 
  arrange(Territory) %>% 
  group_by(Species,Territory, grp = cumsum(c(1, diff(Year) != 65))) %>% 
  group_by(Species,Territory) %>% 
  summarise(Years_appart = ifelse(max(Year)-min(Year) >= 0,"Yes","No"), # Step 1. first and last reported landings are at least 10 years apart
            Consecutive = ifelse(max(grp) >= 5,"Yes","No"), # Step 2. There are at least 5 consecutive catch years
            Catch_over = ifelse(max(RMean >= 1000),"Yes","No") # Step 3. 3) The catch in a particular area (LME) is at least 1,000 tonnes.
            ) %>% 
   gather("Step","Treshold",Years_appart:Catch_over) %>% 
   filter(Treshold == "Yes")

 
 # Evaluate stocks
 
 # Filter data that does not satisfy tresholds

 Landings_Peaks <- Data %>% 
  group_by(Species,Territory) %>% 
  summarise(Max_Peak = max(RMean,na.rm=T))
 
 Eval_Data <- Data %>% 
  semi_join(Tresholds,
            by = c("Species","Territory")) %>% 
   left_join(Landings_Peaks,
             by = c("Species","Territory"))
 
 Peak_Year <- Eval_Data %>% 
   filter(RMean == Max_Peak) %>% 
   select(Species,Territory,EEZID,Y_Max_Peak = Year)

 Post_Max_Min <- Eval_Data %>% 
   left_join(Peak_Year) %>% 
   filter(Year > Y_Max_Peak) %>% 
   group_by(Species,Territory,EEZID) %>% 
   summarise(Post_Max_Min = min(RMean,na.rm=T))
 
 Y_Post_Max_Min <- Eval_Data %>% 
   left_join(Post_Max_Min) %>% 
   filter(RMean == Post_Max_Min) %>% 
   select(Species,Territory,EEZID,Y_Post_Max_Min = Year)
 
 Data_Status <- Eval_Data %>% 
   left_join(Peak_Year,
             by = c("Species","Territory","EEZID")) %>%
   left_join(Post_Max_Min,
             by = c("Species","Territory","EEZID")) %>% 
   left_join(Y_Post_Max_Min,
             by = c("Species","Territory","EEZID")) %>% 
   rename(Y_RMean = Year) %>% 
   mutate(Status = ifelse(Y_RMean > Y_Post_Max_Min & Post_Max_Min < (Max_Peak*0.10) & (RMean > (Max_Peak*0.10) & RMean < (Max_Peak*0.50)),"Rebuilding",
                          ifelse((Y_RMean < Y_Max_Peak & RMean <= (Max_Peak*0.50) | Y_Max_Peak == max(Y_RMean)),"Developing",
                                 ifelse(RMean > Max_Peak*0.50,"Max Exploited",
                                        ifelse(Y_RMean > Y_Max_Peak & (RMean > (Max_Peak*0.10) & RMean < (Max_Peak*0.50)),"Over Exploited",
                                               ifelse(Y_RMean > Y_Max_Peak & RMean < Max_Peak*0.10,"Collapsed",
                                                      "No Status")
                                        )
                                 )
                          )
   )
   ) %>% 
   filter(Y_RMean > 2004) %>% 
   group_by(Species,EEZID,Territory,Status) %>% 
   summarise(n_Status= n()) %>% 
   group_by(Species,EEZID,Territory) %>% 
   top_n(1,n_Status)
 
 
 # Manual estimation
 
 data.frame(
   Y_RMean = 1980,
   RMean = 642187,
   Max_Peak = 1298712,
   Y_Max_Peak = 1990,
   Post_Max_Min = 681967,
   Y_Post_Max_Min = 2010,
   Y_RMean = 2014
 ) %>% 
   mutate(Status = ifelse(Y_RMean > Y_Post_Max_Min & Post_Max_Min < (Max_Peak*0.10) & (RMean > (Max_Peak*0.10) & RMean < (Max_Peak*0.50)),"Rebuilding",
                          ifelse((Y_RMean < Y_Max_Peak & RMean <= (Max_Peak*0.50) | Y_Max_Peak == max(Y_RMean)),"Developing",
                                 ifelse(RMean > Max_Peak*0.50,"Max Exploited",
                                        ifelse(Y_RMean > Y_Max_Peak & (RMean > (Max_Peak*0.10) & RMean < (Max_Peak*0.50))," Over Exploited",
                                               ifelse(Y_RMean > Y_Max_Peak & RMean < Max_Peak*0.10,"Collapsed",
                                                      "NA")
                                        )
                                 )
                          )
   )
   )
 
```




```{r Top_spp_Circle_Diagram, eval =F, echo = F}

# Top 5 shared species per marine environment (number of countries sharing the species)
Top_Species <- Species_Trans %>% 
  mutate(scientific_name = paste(Genus,Species)) %>%
  left_join(Species_environ_list) %>% 
  mutate(DemersPelag = replace_na(DemersPelag, "Other")) %>% 
  # group_by(TaxonKey,TaxonName,CommonName,DemersPelag) %>% 
  # summarise(Sum_Countries =sum(n_countries,na.rm=T)) %>% 
  group_by(DemersPelag) %>% 
  top_n(5,n_countries)

# Countries that share the top 10
Top_Spp_Countries <- Clean_Results_Trans %>% 
  filter(
    Area_Index < Min_AI |
      Area_Index > Max_AI,
    Model_Index == MI,
    Same_Nation == "No",
    TaxonKey %in% Top_Species$TaxonKey
  ) %>% 
  left_join(Species_Trans) %>% 
  rename(scientific_name =TaxonName) %>%
  left_join(Species_environ_list) %>% 
  mutate(from = paste(Genus,"\n",Species,sep=""),
         DemersPelag = replace_na(DemersPelag, "Other")) %>%
  group_by(
    # from,
    from = scientific_name,
           to=CT_fishing_entity,
           DemersPelag
  ) %>% 
  summarise(value=n()
  ) #%>%
  # filter(DemersPelag == "demersal") %>%
  # select(-DemersPelag)


####________________###
# Circulize package ####
# https://jokergoo.github.io/circlize_book/book/
####________________###
  
# To set links color 
Bins <- as.numeric(cut(Top_Spp_Countries$value,breaks = 5)) # By size of sharing

# To get country's flags... https://flagpedia.net/download
flags <- c(paste("Temporal_Data/flags-mini/",list.files("Temporal_Data/flags-mini/"),sep=""))

# List of Ecosystems
Classification <- Top_Species %>% group_by(DemersPelag) %>% summarise(n()) %>%  pull(DemersPelag)

####________________ PLOT PER ECOSYSTEM _____________________ ###

for(s in 1:2){ # sclae loop
  for(i in 1:length(Classification)) {
    # for(i in 1:2) { # for testing
    
    # Set scales to plott both absolut and proportional values
    if(s == 1){
      Scales <- "TRUE"
    }else{
      Scales <- "FALSE"
    }
    
    # Saving the plot
    Plot_name <- paste(Figures_Path,Classification[i],Scales,".tiff",sep="")
    tiff(Plot_name, width = 5, height = 5, units = 'in', res = 500)
    
    # Subsetting the data for each plot
    DemersPelag_i <- Classification[i]
    
    Data <- Top_Ten_Spp_Countries %>% 
      filter(DemersPelag %in% DemersPelag_i) %>% 
      select(-3)
    
    # Use to set links' colors to each species
    Speceis_cols <- Data %>% group_by(from) %>% summarise(n()) %>% pull(from)
    
    # The base plot
    circos.clear()
    chordDiagram(Data, 
                 annotationTrack = c("grid", "axis"), # keep grid and axis but not labels
                 annotationTrackHeight = c(0.001, 0.1), # set links close to the axis
                 directional = 1, # direction of arrows
                 direction.type = c("diffHeight", "arrows"), # use arrows
                 grid.col = "grey",
                 # if col == Bins then colors will change depending of value
                 # col = ifelse(Bins == 1,"#046C9A", # deep blue
                 #              ifelse(Bins == 2,"#78B7C5", #light blue
                 #                     ifelse(Bins == 3,"#EBCC2A", #yellow
                 #                            ifelse(Bins == 4, "#E1AF00", #cream
                 #                                   "#F21A00")))), #red
                 # if col == Species_cols then colors will change depending of species
                 col = ifelse(Data$from == Speceis_cols[1],"#FF0000", # deep blue
                              ifelse(Data$from == Speceis_cols[2],"#00A08A", #light blue
                                     ifelse(Data$from == Speceis_cols[3],"#F2AD00", #yellow
                                            ifelse(Data$from == Speceis_cols[4], "#F98400", #cream
                                                   "#5BBCD6")))), #red
                 # link.arr.col = wes_palette("Zissou1"), 
                 link.arr.type = "big.arrow",# make links big arrows
                 diffHeight = uh(-0.5, "mm"), # brings the arrow to the bottom of the source
                 scale = Scales, # fraction of each species to total share of each country instead of absolute value
                 preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(Data))))) # I have no idea but helps with the labels
    )
    
    #  Function to inlcude other layers
    circos.track(track.index = 1, panel.fun = function(x, y) {
      xlim = get.cell.meta.data("xlim")
      xplot = get.cell.meta.data("xplot")
      ylim = get.cell.meta.data("ylim")
      sector.name = get.cell.meta.data("sector.index")
      
      # Add labels
      circos.text(mean(xlim),
                  ylim[1],
                  sector.name,
                  facing = "clockwise",
                  niceFacing = TRUE,
                  adj = c(-0.2, 0.5),
                  col = "black",
                  cex = 0.6) # size of labels
      
      # Add country's flags instead of names (still need to link names to falgs)
      
      # library(EBImage)
      # pos = circlize:::polar2Cartesian(circlize(CELL_META$xcenter, CELL_META$ycenter))
      # image = EBImage::readImage(flags[CELL_META$sector.numeric.index])
      # 
      # rasterImage(image,
      #             xleft = pos[1, 1] - 0.006, 
      #             ybottom = pos[1, 2] - 0.005,
      #             xright = pos[1, 1] + 0.05,
      #             ytop = pos[1, 2]+ 0.04
      #             )
      
      # END FLAGS TRYOUT
      
      # Set plot Title
      Title <- paste("Top",Classification[i], "Species",sep =" ")
      title(Title)
      
    }, bg.border = NA) #end of circos.track
    
    dev.off()
  } # close for loop
} #close scale loop

```

# Sensitivity Analysis


```{r Sensitivity_Area_Treshold, eval = T, echo = F}

# Model Index
MI <- 100 # Model Index

####_____End Select Tresholds_______ ###

Area_Index_Level <- seq(.1,0.5,0.1)


p <- list()
i = NULL

for(i in 1:length(Area_Index_Level)){
  
  data <- Clean_Results_Trans %>% 
    filter(
      Area_Index >= Area_Index_Level[i],
      Area_Index <= 1-Area_Index_Level[i],
      Model_Index == MI
    ) %>% 
    group_by(Territory) %>% 
    summarise(
      n_trans_spp = length(unique(TaxonKey)),
      n_Neighbours = length(unique(Neighbour)),
      Trans_Rate = n_trans_spp/n_Neighbours
    )
  
  Median_data <- median(data$n_trans_spp)
  print(Median_data)
  
  p[[i]] <- ggplot(data) +
    geom_histogram(aes(n_trans_spp),
                   binwidth = 10, 
                   colour = "white"
    ) +
    labs(
      x = "Transboundary species (n)",
      y = "Frequency of EEZs",
      title= paste("Using a",(Area_Index_Level[i]*100),"% area treshold. (Median",Median_data,")")
    ) +
    # ggtitle(paste("Using a",(Area_Index_Level[i]*100),"% area treshold. (Median",Median_data,")")) +
    ggtheme_plot()
  
}

ggsave(
    plot = do.call(gridExtra::grid.arrange,p),
    width = 8,
    height = 8,
    units = "in",
    filename = "Area_Tresholds.png",
    path = "/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Sensitivity_Analysis"
  )

```


#Problem solving



### First world Anchovies

In a first run the model suggests anchovies "Engraulis ringens" (600004) is transboundary between US-Mex-Can. I'm exploring this since all four models agree...

Found the probelm, Gab's coordinate system, hecne the data, are in different system than DBEM and SAU data...


```{r Trans_Spp_Function, eval= F ,echo = T,warning = F,message = F}

### DATA EXTRA NEEDED 

# DBEM Coordinate system
Coor <- fread(paste(Data_Path,"Spatial_Data/Lon_Lat_DBEM.txt",sep=""),header = FALSE)
colnames(Coor) <- c("INDEX","Longitude","Latitude")
EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))
EEZ_CellID <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/EEZ_CellID.xlsx",sep=""))
colnames(EEZ_CellID) <- c("EEZID","INDEX")

CoorG <- read.csv(paste(Data_Path,"Spatial_Data/coordinates_gab.csv",sep="")) %>% 
  mutate(INDEX = seq(1,259200,1))

# colnames(CoorG) <- c("INDEX","Longitude","Latitude")
coords <- CoorG[order(CoorG$Latitude, rev(CoorG$Longitude),decreasing=TRUE), ] 

# Explore model step by step

# Get Catch Data
Anchoveta_Dist <- GetSppDist(600004,"All",CoorG)


Anchoveta_Dist_Coor <- Anchoveta_Dist %>% 
  left_join(CoorG)

# Swap coordinate system to match DBEM and SAU
Anchoveta_Dist_Coor_Fix <- Anchoveta_Dist_Coor[order(Anchoveta_Dist_Coor$Latitude, rev(Anchoveta_Dist_Coor$Longitude),decreasing=TRUE), ] 


x <- Anchoveta_Dist %>% 
  left_join(EEZ_CellID) %>% 
  left_join(EEZIDs_List) %>% 
  filter(
    # Model == "Occ",
    Value >0)


# head(x)
# Exploring using Vicky's data

ggplot(x) +
  geom_tile(aes(
    x = Longitude,
    y = Latitude,
    fill = Name,
    color = Name
  )
  ) +
  facet_wrap(~Model)


Spp_Trans <- bind_rows(
    mclapply(
      600004, FUN =EstTransIndex, Model = "All", Neighbours = Neighbour_List, Coord = CoorG
    )
  )


  # Estimate total spp distribution within neighbours
  
  Trans_Spp <- SppDist %>%
    filter(INDEX %in% Neighbours$INDEX) %>% # Filter data only located within EEZs
    mutate(Value = ifelse(Value > 0, 1,0)) %>%  # For now using SAU_C as presence absence
    group_by(TaxonKey,
             INDEX
    ) %>%
    summarise(Model_Index = mean(Value,na.rm=T)) %>%
    filter(Model_Index > 0) %>%
    mutate(Model_Index = Model_Index*100) %>%
    left_join(Neighbours,
              by = "INDEX")
    
    Test <- Trans_Spp %>% 
      filter(Name == "USA (West Coast)" & Model_Index ==100)


 # Explore only SAU catch data

# Get Catch Data
Anchoveta_Dist <- GetSppDist(Spp,"SAU_C")
    
# Get Mex, Can and USA W coast Grid
Anchoveta_Dist_EEZ <- Anchoveta_Dist %>% 
  

Anchoveta_NA <-  Anchoveta_Dist%>% 
  filter(INDEX %in% North_America$INDEX) %>% 
  gather("Year","Tonnes",CATCH.1:CATCH.65) %>% 
  group_by(Year) %>% 
  summarise(Sum_T = sum(Tonnes, na.rm =T))



```


### Overcounting transboundary stocks

In a first run, Australia results in many transboundary stocks, I believe this is because it is counting the number of countries that that the species share (e.g. one species 6 countries = 6 transboundary spp) rather than 1 speces 6 countries = 1 trans spp.

**Problem fixed.** Now we can estimate the number of transboundary species as well as the number of countries/regions that each country shares per species.

```{Australia_case, eval =F, echo = F}

Australia <- Results_Data %>% 
  filter(Name == "Australia")

Original_Australia <-Australia %>% 
  filter(Model_Index >= 50#,
         # Trans_Index >= 0.10
         ) %>% 
  group_by(Name,Model_Index) %>% 
  summarise(n_Trans_Spp = n()) %>% 
  filter(Model_Index == 100)

## Testing the waters

Explore_Australia <- Australia %>% 
  filter(Model_Index >= 50#,
         # Trans_Index >= 0.10
         ) %>% 
  slice(1:20) %>% 
  group_by(Name,Model_Index) %>% 
  summarise(
    n_trans = length(unique(TaxonKey)),
    n_countries = length(unique(Neighbour_Territory)),
    )

```

### Fixing counts within EEZs

In the first run. Countries where EEZs are devided but touching (e.g. South Africa inidan and atlantic coasts) are double counted.

This might be fixed with Tayler's data of EEZs to ISOs... He did it manually so it does not work! 

```{South_Africa_case, eval =F, echo = F}

# Tyler E.'s' data
EEZ_ISO <- read.csv("/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Spatial_Data/EEZID_ISO_TylEd.csv", comment.char="#")

#SAU / Vicky's data
EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))

EEZ_CellID <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/EEZ_CellID.xlsx",sep=""))
colnames(EEZ_CellID) <- c("EEZID","INDEX")

# Worlds adata

# The path
path_world <- paste(Data_Path,"Spatial_Data/World_EEZ_v10_2018",sep="")
# #The File
fnam_world <- "eez_v10.shp"
# #Load it!
# 
World_EEZs <- st_read(dsn = path_world,
                      layer =file_path_sans_ext(fnam_world))

head(World_EEZs)

World_EEZs %>% 
  filter(
    # Territory1 == "South Africa",
    ISO_Ter1 == "ZAF") %>% 
  head()

# Get ISO and territory names from world map
ISO_Ter <- World_EEZs %>%
  select(ISO_Ter1,Territory1) %>% 
  as.data.frame() %>% 
  select(ISO_Ter1,Territory1)

head(ISO_Ter)

# I think EEZID equals ISO when not devided... 

EZZID_Yes_ISO <- ISO_Ter %>% 
  semi_join(ISO_Ter,
            by ="ISO_Ter1") %>% 
  rename(Name = Territory1) %>% 
  # head() %>% 
  left_join(EEZIDs_List,
            by = "Name")


EEZ_ISO_Clean <- ISO_Ter %>% 
  left_join(EEZ_ISO,
            by = "ISO_Ter1")

SA <- Results_Data %>% 
  filter(stringr::str_detect(Name,"South Africa"))


## Creating a subset dataset so i can work on my laptop and not remoteley

SubsetData <- Clean_Results %>% 
  filter(Country_Territory=="USA (East Coast)")

write.csv(SubsetData,
          "SubsetData.csv",
          row.names = F) # Using USA East coast and Gulf as example

###_____________________________ ###

# Loading subsetted data

Clean_Results <- read.csv("~/GitHub/FishForVisa/Temporal_Data/SubsetData.csv")

sau_eez_fes <- read.csv("~/GitHub/FishForVisa/Temporal_Data/sau_eez_fes.csv")
  

Neighbourd_Territory_T <- Clean_Results %>% 
  group_by(eez_name=Neighbour_Territory) %>% 
  summarise() %>%
  left_join(sau_eez_fes,
            by = "eez_name") %>% 
  select(Neighbour_Territory= eez_name,
         NT_fishing_entity=fishing_entity
         )

Country_Territory_T <- Clean_Results %>% 
  group_by(eez_name=Country_Territory) %>% 
  summarise() %>%
  left_join(sau_eez_fes,
            by = "eez_name")  %>% 
  select(Country_Territory= eez_name,
         CT_fishing_entity=fishing_entity)

Non_duplicate_Data <- Clean_Results %>%   
  left_join(Neighbourd_Territory_T,
              by ="Neighbour_Territory") %>% 
  left_join(Country_Territory_T,
              by ="Country_Territory") %>% 
  mutate(
    Same_Nation = ifelse(CT_fishing_entity==NT_fishing_entity,"Yes","No")
  ) %>% 
  filter(Same_Nation == "No")


# FIXED!!!!! 

```

- **Done debugging**

### Missing stocks

There are places like Peru-Chile or Alaska-Canada that should have trans spp... In Alaska the issue is that Alaska doesn't actually exist as a separate shapefile...

```{r Missing_stocks, eval =F}

Exploited_Species <- fread(paste(Data_Path,"Distribution_Data/exploited_species_list.csv",sep=""))

Clean_sau_eez_fes <- sau_eez_fes %>% 
  gather("Type","FishingRegion",2,4) %>% 
  left_join(sau_eez_fes,
            by = ("fishing_entity_id")
            ) %>% 
  group_by(FishingRegion,fishing_entity) %>% 
  summarise(n())


# The Alaska paradox
# It's a problem of the NAs, fixed.

USA_West <- Results_Data %>% 
  filter(Country_Territory == "USA (West Coast)") %>% 
  left_join(Exploited_Species,
            by = "TaxonKey")

# Northern sea Russia
Russia_map <- World_EEZs %>% 
  filter(stringr::str_detect(Name,"Russia")) %>% 
  st_simplify(preserveTopology = TRUE, dTolerance = 100) 

head(Russia_map)

ggplot(Russia_map) +
  geom_sf(aes(fill = Name)) 
# Shapefiles not matching
# Russia (Laptev to Chukchi Sea)
# Russia (Kara Sea)

Russian_Regions <- c("Russia (Laptev to Chukchi Sea)","Russia (Kara Sea)")

Russia_Results <- Results_Data %>% 
  filter(stringr::str_detect(Country_Territory,"Russia"))
  
unique(Russia_Results$Country_Territory)
# Missing Laptev to Chukchi sea

### What about Vicky's data
#SAU / Vicky's data
EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))

Russia_EEZlist <- EEZIDs_List %>% 
  filter(stringr::str_detect(Name,"Russia"))
  
unique(Russia_EEZlist$Name)

### So maybe there are no Neighbours?
Neighbour_List <- fread(paste(Data_Path,"Spatial_Data/Neighbour_List.csv", sep =""))

Russia_Neighbour <- Neighbour_List %>% 
  filter(stringr::str_detect(Name,"Russia"))
  
unique(Russia_Neighbour$Country_Territory)

# OK So Kara Sea has no borders outside Russia, hence white. Now Laptev does have borders but No species... which is weird... Paific Halibut?

# I manually ran the function to see what's going on

# ggplot() +
#   geom_sf(data = Russia_map, aes(colour = Name)) +
#   geom_tile(data = subset(SppDist, Value !=0),
#             aes(
#     x = Longitude,
#     y = Latitude,
#     fill = log10(Value)
#   ) 
#   ) +
#   facet_wrap(~Model)

# The main issue is that there is no catch data there...

```

### Pierrs massive discrete stocks

```{r Pierrs_Discretion, eval = F ,echo = T,warning = F,message = F}

Pierre <-  Clean_Results_Trans %>% 
  filter(Territory == "Saint Pierre & Miquelon (France)") %>% 
  left_join(Exploited_Species,
            by = "TaxonKey")

# Very wrong!
# using 600051 to see what's the problem with the Area index

# Found the problem, Territory and Neighbour were switched un the last step of the EstTransSpp function

```

### Côte de Ivory missing data

For some reason Côte de ivory is missing data. It was fixed at the begining when I was averaging 1951 to 1961 instead of 2004 to 2014, but now is somehow back to cero.

```{Cote_Deivory, eval =F, echo =F}

# It might be a problem in the name côte de'ivory....
# Nope, both INDEX and neighbours datasets are names alike

# Run getSppDistribution function with this:
Model="All"
Coord=CoorG

# Spp <- 600423 #This species should work

# Its a problem with compabillity between Windows and MAC. Fixed by changing the neighbours csv. to excell

# Now Check Vietnam...Curacao and Réunion...
# In INDEXES "Vietnam" in all others "Viet Nam"
# Fixed directly on the excell

# The russioan probelmo

# Load neighbours data from previouse routine
Neighbours_Data <- read_excel(paste(Data_Path,"Spatial_Data/EEZ_Neighbour_List.xlsx", sep =""))


EEZCellIUD913 <- EEZ_CellID %>% 
  filter(EEZID == 913)

R912 <- Neighbours_Data %>% 
  filter(ID == 912)

R913 <- Neighbours_Data %>% 
  filter(ID == 913)

anti_join(R912,R913)


Index_Code913 <- Index_Code %>% 
  filter(EEZID == 913)


Neighbours_Data %>% 
  filter(INDEX %in% Index_Code913$INDEX)

# SAU relations between INDEX and Country's EEZs
EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))
# EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_JEPA_92019.xlsx",sep=""))
EEZ_CellID <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/EEZ_CellID.xlsx",sep=""))
# EEZ_CellID <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_JEPA_92019.xlsx",sep=""))
colnames(EEZ_CellID) <- c("EEZID","INDEX")

Index_Code <- EEZIDs_List %>% 
  left_join(EEZ_CellID) %>% 
  rename(Territory = Name)

# The path
path_world <- paste(Data_Path,"Spatial_Data/SAU_Shapefile/",sep="")
# #The File

fnam_world <- "SAUEEZ_July2015.shp"
World_sf <- st_read(dsn = path_world,
                    layer =file_path_sans_ext(fnam_world)) %>% 
  rename(Territory = Name)


x <- Neighbours_Data %>%
  select(-Neighbour) %>% 
  group_by(Territory) %>% 
  distinct() %>% 
  anti_join(Index_Code) %>% 
  group_by(Territory) %>% 
  summarise(n());x

# World_sf %>% 
#   filter(Territory %in% x$Territory)


# Fuck it! Re-run Neighbours code... 

Russians <- c("Russia (Laptev to Chukchi Sea)", #913
              "US Virgin Islands") #912

SF_Names <- 850

Russian_Index <- Index_Code %>% 
  filter(Territory %in% Russians)

unique(Russian_Index$EEZID)
unique(Russian_Index$Territory)

World_sf %>% 
  # filter(Territory == "Russia (Laptev to Chukchi Sea)") # EEZid 912
  # filter(Territory == "Russia (Kara Sea)") # EEZid also 912
  filter(Territory %in% Russians) %>% 
  ggplot() +
  geom_sf(aes(fill = Territory))


unique(Russian_sf$Territory)

# split shapefile by DF
 Russian_id <- World_sf %>% 
  filter(Territory %in% Russians) %>% 
  left_join(Russian_Index, by= "Territory") %>%  
  mutate(EEZID = ifelse(Territory == "Russia (Kara Sea)",912,913)) %>% 
  filter(EEZID == 913) %>% 
  st_simplify(preserveTopology = TRUE, dTolerance = 1000)
  
 
 ggplot(Russian_id) +
   geom_sf(aes())

 # ok! 

# split shapefile by DF
Russia_id_912_913 <- World_sf %>% 
  filter(Territory %in% Russians) %>% 
  left_join(Russian_Index, by= "Territory") %>%  
  mutate(EEZID = ifelse(Territory == "Russia (Kara Sea)",912,913)) %>% 
  as.data.frame() %>% 
  ungroup() %>% 
  select(Territory,INDEX,EEZID)

write.csv(Russia_id_912_913,
         "Russia_id_912_913.csv",
         row.names = F)
  
head(x)
  

```

# Extra Analysis
## Extra Analysis; Functions

```{r Trans_Spp_Function_All, eval = F ,echo = T,warning = F,message = F}

# Function to determine whether or not a species is transboundary for each model

# Varibales needed
# Spp: Species to be analized, data with presence/absence per gridcell
# Index_EEZ: Reference list of all INDEX that fall within EEZs
# EEZ_Size: Number of grid-cells that each EEZ has
# Neighbours: Reference list of neighbouring countries

# Needs getSppDist

#### For testing 
# Spp <- 600059
# Model <- "All"
# Neighbours <- Neighbour_List
# Coord = CoorG
# __________________________________

# The function
EstTransIndex <- function(Spp,Model,Neighbours,Coord,Save="Y"){
  
  # Get model data from spps
  SppDist <- GetSppDist(Spp,Model,Coord)
  
  # Result 1. Number of Countries that share the species
  
  #____________ ESTIMATING MODEL INDEX (TRESHOLD 1)_________ #
  Trans_Spp <- SppDist %>%
    filter(INDEX %in% Neighbours$INDEX,# Filter data only located within EEZs
           Model != "SAU_C") %>% # Only using observational and modelled data
    mutate(Value = ifelse(Value > 0, 1,0)) %>%
    left_join(EEZ_CellID,
              by = "INDEX") %>% 
    left_join(EEZIDs_List,
              by = "EEZID")
  
  # MODEL INDEX (TRESHOLDS 1 & 2) #
  Model_Index_D <- Trans_Spp %>% 
    group_by(Name,
             TaxonKey,
             Model
    ) %>% 
    summarise(n_cells_spp = n()) %>% 
    select(-n_cells_spp)
  
    #____________ ESTIMATING DISTRIBUTION INDEX (TRESHOLD 3)_________ #
   # The number of species' cells present within each country's EEZ
  
  #Step 1.  Get EEZ id and Neighbour
  Neighbours_EEZ <- Neighbours %>% 
  group_by(EEZID,Country_Territory,Neighbour_Territory) %>% 
  summarise(n=n()) %>% 
  ungroup() %>% 
  select(-n)

  # Step 2. Determines the amount of grids present in each country
  Spp_Grid <- Trans_Spp %>% 
    group_by(TaxonKey,
             Model, 
             EEZID) %>% 
    summarise(n_spp_eez = length(unique(INDEX))) %>% 
    left_join(Neighbours_EEZ,
              by = "EEZID") %>% 
    filter(Country_Territory %in% Trans_Spp$Name, #Filter out unwanted Neighbours (those who don't have grids within but get included because they are Neighbours)
           Neighbour_Territory %in% Trans_Spp$Name)
  
  # Step 3. Sum total grids per Neighbours
  
  # Split dataframes to merge latter
  Country_Territory_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      Model_Index, # Un-comment after producing models x datasets
      TaxonKey,Name=Country_Territory,n_spp_eez
    )
  
  Neighbour_Territory_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      Model_Index,
      TaxonKey,n_spp_eez,Name=Neighbour_Territory, Country_Territory
    )

  # Merge dataframes to get totals per Neighbourds
  Area_Index_D <- full_join(Country_Territory_T,
                           Neighbour_Territory_T, by = c("Name","TaxonKey","Model")) %>%
    rowwise() %>%
    mutate(Spp_Total = sum(n_spp_eez.x,n_spp_eez.y,na.rm=T)) %>% # Total gridcelles per Neighbours
    distinct() %>% # Removes false duplicates from `full_join()`
    rename(Neighbour_Territory = Name,
           n_spp_Country = n_spp_eez.x,
           n_spp_Neighbour = n_spp_eez.y) %>% 
    mutate(Area_Index = n_spp_Country/Spp_Total) %>%  #Estimates the proportion of grids per country
    select(1:4,6,8)

  #____________ FINAL INDEX TABLE_________ #
  Indexes <- Model_Index_D %>% 
  rename(Country_Territory = Name) %>% 
  full_join(Area_Index_D,
            by = c("TaxonKey","Country_Territory","Model")
  ) %>% 
    filter(!is.na(Area_Index))%>%  # Remove cases where the country does not pass the area_index and viceversa
    select(Model,TaxonKey,Country_Territory,Neighbour_Territory,everything())

  ### Save spp dataframe
  
  if(nrow(Indexes) > 0 & Save == "Y"){
    
    File_Name <- paste(Spp,"_Transboundary.csv",sep = "")
    Save_Path <- paste(Results_Path,"All_Models/",File_Name,sep="")
    
    write.csv(Indexes,
              Save_Path,
              row.names = F)
    
  }
  
  if(nrow(Indexes) == 0 & Save == "Y"){
    
# Reads dataset of Non transboundary species
    Non_Transboundary_Data <- fread(paste(Results_Path,"All_Models/","Non_Transboundary_Data.csv",sep=""))
    
    # Get current Spp that is not transboundary 
    Current_Spp <- tibble(Non_trans = Spp)
    
    # Combine new spp with others
    New_Non <- Non_Transboundary_Data %>% 
      bind_rows(Current_Spp)
    
    # Set a name for file and saves data
    New_Non_Name <- paste(Results_Path,"All_Models/","Non_Transboundary_Data.csv",sep="")
    write.csv(New_Non, New_Non_Name, row.names = F)
    
  }
  
  ### Function return
  
  EstTransIndex=Indexes # A dataframe with 
  
}


### Testing Function ####
# Spp <- 600006
# Model <- "All"
# Neighbours <- Neighbour_List
# 
# Tryout <- EstTransIndex(Spp,Model,Neighbours,CoorG,Save="N")
# 
# Over_20 <-Tryout %>% 
#     filter(Area_Index > 0.20,
#            Area_Index < 0.80)
  
# Spp <- NULL
# Model <- NULL

```

## Extra Analysis; Results

### Maps for each model/dataset
```{Tran_country_Map_All, eval =F, echo =F}

World_EEZs_simple <- World_EEZs %>%
  st_transform(crs = 4326) %>% # 4326
  st_simplify(preserveTopology = TRUE, dTolerance = 0.1) %>%
  left_join(TenTwenyfive, by ="Name") #%>%
  # filter(!is.na(n_trans)) #%>%
  # st_transform(crs = 3832)

# head(World_EEZs_simple)
# World_EEZs_simple %>% 
#   filter(Name == "Chile")

pal <- wes_palette("Zissou1", 100, type = "continuous")

Mod <- unique(TenTwenyfive$Model)

# Loop through all variables
for(v in 1:length(Mod)){
  
  Model_List <- Mod[v]
  
  plot <- ggplot(data = subset(World_EEZs_simple,Model %in% Model_List)) +
    geom_sf(aes(fill = n_trans)) +
    scale_fill_gradientn(colours = pal,
                         na.value = "white") +
    ggtheme_map() +
    ggtitle(paste(Model_List))
  
  # Name plot
  Plot_Name <- paste(Model_List,"plot.png",sep="_")
  
  # Save plot
  ggsave(
    plot = plot,
    width = 14,
    height = 10,
    units = "in",
    filename = Plot_Name,
    path = "/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Figures/All_Models/"
  )
    
  }

```

```{r Continent_PNG, eval =F }


names(UN_Regions)
# Load Land shapefile
path_world_land <- paste(Data_Path,"Spatial_Data/ne_50m_admin_0_countries",sep="")
# #The File
fnam_world_land <- "ne_50m_admin_0_countries.shp"

World_land_sf <- st_read(dsn = path_world_land,
                         layer =file_path_sans_ext(fnam_world_land)) %>% 
  st_transform(crs = 4326)

head(World_land_sf)

Regions <- unique(World_land_sf$REGION_UN)
# r= 1

for(r in 1:length(Regions)){
  
  Oceania <- World_land_sf %>%
    st_transform(crs = 3832)
    
  
  Oceania %>% 
    filter(REGION_UN %in% Regions[5]) %>% 
    ggplot() +
    geom_sf(aes(),fill="black",colour = "black") +
    ggtheme_map() #+
    # coord_sf(xlim = c(-180, 90), ylim = c(-90, 90), expand = FALSE)
  
  Plot_Name <-paste(Regions[5],".png",sep="")
  
  ggsave(Plot_Name,
       plot = last_plot(),
       width = 4,
       height = 4,
       units = "in",
       path = "/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Images_Data/"
)
  
}




```

```{r round_map, eval = F, echo = F}
# #### Round map tryout 

# ### EEZ shapefile
# eez  = readRDS(paste(Data_Path,"Spatial_Data/eez_simplified.rds",sep="")) #taken from cotterel https://github.com/cottrellr/shocks
# 
# eez = spTransform(eez, CRS("+proj=longlat"))
# eez = spTransform(eez, CRS("+proj=wintri"))
# eez = fortify(eez) 
# 
# World_sf_si <- World_sf %>%
#   st_transform(crs = 4326
# 

# mapworld = fortify(spTransform(rworldmap::getMap(), CRS("+proj=wintri")))
# 
# mapworld<- mapworld %>% 
#   rename(Territory = id) %>% 
#   left_join(Data,
#             by = "Territory") %>% 
#   left_join(Data_EEZ,
#             by = "Territory") %>% 
#   rename(id = Territory)
# 
# # head(mapworld)
# 
# #create map boundary
# ll.to.wt <- function (points)
#   as.data.frame(spTransform(SpatialPoints(points, CRS("+proj=longlat")),
#                             CRS("+proj=wintri")))
#  
# lseq = seq(-85, 85, by=.25)
# boundary <- ll.to.wt(data.frame(
#   long = c(rep(-180, length(lseq)), rep(180, length(lseq)), -180),
#   lat  = c(lseq,                    rev(lseq),          lseq[1])))
#  
# # New facet label names for dose variable
# ggplot()+
#   geom_polygon(data=boundary, aes(x=long, y=lat), fill="azure") +
#   geom_map(data=mapworld, map=mapworld, aes(map_id=id, x=long, y=lat), fill ="gray93", colour=NA) +
#   geom_polygon(data = mapworld, 
#                aes(
#                  x = long,
#                  y = lat,
#                  group = group,
#                  fill = BinsLan
#                ),
#                colour="grey") +
#   geom_polygon(data = mapworld, 
#                aes(
#                  x = long,
#                  y = lat,
#                  group = group,
#                  fill = Bins)
#                ) +
#   geom_path(data=eez, aes(x=long,y=lat, group=group),colour="grey") +
  # geom_point(data=ui, aes(x=long, y=lat, size=M, color=M), alpha=0.9) +
  # geom_text_repel(data=ui,aes(x=long, y=lat, label=un.name), size=2.5, color = 'black',
  #                 box.padding = unit(0.5, "lines"),
  #                 point.padding = unit(0.5, "lines"),
  #                 segment.color = 'grey50') +
  # scale_radius(range = c(1, 2)) #+
  # scale_colour_distiller(palette ="Spectral", direction = 1, limits=c(0,1), breaks=c(c(0,1))) + # or direction=1
  # theme_map()+
#   theme(legend.key = element_blank(),
#         strip.background = element_blank(),
#         legend.position = "none",
#         text = element_text(size=12,face="bold"))+
#   facet_wrap(~variable, scales = "free", ncol=1)+scale_shape(guide=FALSE)+scale_size(guide=FALSE)
# y=tag_facet(q, tag_pool = c("d","e","f"))

```

# Old code
```{r OLD_funEstNeighbours, eval = F, echo=T}
# Determine which countries are Neighbours

# Method adopted from Adrew Heiss
# https://gist.github.com/andrewheiss/926b9d60a26e29f6bf32

EstNeighbours <- function(Shapefile){
  
  # Get the list using the poly2nb function
  
  Neighbour_List <- poly2nb(Shapefile)
  
  # Convert te nb data to a Matrix of crossing references
  Neighbour_Matrix <- nb2mat(Neighbour_List,
                            style="B", 
                            zero.policy=TRUE)
  
  # Rename the matrix axis
  colnames(Neighbour_Matrix) <- rownames(Neighbour_Matrix)
  
  
  # Get the names of the countries for identifying them
  Country_Names <- tibble(id = row.names(Shapefile@data),
                              Country_Territory = as.character(Shapefile@data$Name),
                              Neighbour_Territory = Country_Territory,
                              EEZID = Shapefile@data$EEZID # specific of SAU sf
                              )
  
  # Clean up and transform the Neighbour matrix
  Neighbours <- as.data.frame(Neighbour_Matrix) %>%
    mutate(country = row.names(.)) %>%  # Convert row names to actual column
    gather(Neighbour, present, -country) %>%  # Convert to long
    filter(present == 1) %>%  # Only look at cells with a match
    # Add country names
    left_join(select(Country_Names,
                     -Neighbour_Territory), by=c("country" = "id")) %>%
    left_join(select(Country_Names, 
                     -Country_Territory), by=c("Neighbour" = "id")) %>% 
    select(EEZID = EEZID.x,Country_Territory,Neighbour_Territory) # select final column
 
    # Merge them with SAU data
  
  DBEM_Neighbours_Data <- EEZIDs_List %>% 
  left_join(EEZ_CellID, 
            by = "EEZID") %>% # Asign EEZ id to each country
  left_join(Neighbours, 
            by = "EEZID") %>% # Include all Neighbouring countries 
  filter(Neighbour_Territory != "NA") %>% 
  left_join(Coor,
            by = "INDEX") # Inclu
  
  return(DBEM_Neighbours_Data)
   
}


### Test function

# Subset data for testing function
# SAU_Regions <- as.data.frame(unique(World_EEZs$Name))

# Test_Countries <-c("Mexico (Atlantic)","Mexico (Pacific)","Guatemala (Caribbean)","Guatemala (Pacific)","Belize")
# Test <- World_EEZs[World_EEZs@data$Name %in% Test_Countries, ]

# Running function
# getNeighbours(Test)

#### Works beautifully! 

```

```{r Trans_Spp_Function, eval= T ,echo = T,warning = F,message = F}

# Function to determine whether or not a species is transboundary

# Varibales needed
# Spp: Species to be analized, data with presence/absence per gridcell
# Index_EEZ: Reference list of all INDEX that fall within EEZs
# EEZ_Size: Number of grid-cells that each EEZ has
# Neighbours: Reference list of neighbouring countries

# Needs getSppDist

#### For testing 
# Spp <- 600059
 #Model <- "All"
 #Neighbours <- Neighbour_List
 #Coord = CoorG
# __________________________________

# The function
EstTransIndex <- function(Spp,Model,Neighbours,Coord,Save="Y"){
  
  # Get model data from spps
  SppDist <- GetSppDist(Spp,Model,Coord)
  
  # Result 1. Number of Countries that share the species
  
  #____________ ESTIMATING MODEL INDEX (TRESHOLD 1)_________ #
  Trans_Spp <- SppDist %>%
    filter(INDEX %in% Neighbours$INDEX,# Filter data only located within EEZs
           Model != "SAU_C") %>% # Only using observational and modelled data
    mutate(Value = ifelse(Value > 0, 1,0)) %>%  
    filter(Value > 0) %>%
    group_by(TaxonKey,
             INDEX
    ) %>%
    summarise(Model_Index = mean(Value,na.rm=T)
    ) %>%
    filter(Model_Index > 0) %>%
    # ____________ ESTIMATING FUNDAMENTAL NICHE (TRESHOLD 2)_________ #
    left_join(SppDist,
              by = c("TaxonKey","INDEX")) %>%
    filter(Model == "SAU_C", # Only keeping cells where SAU catch exists
           Value > 0) %>%
    mutate(Model_Index = Model_Index*100) %>%
    select(-Model, -Value, -Latitude,-Longitude) %>%
    left_join(EEZ_CellID,
              by = "INDEX") %>% 
    left_join(EEZIDs_List,
              by = "EEZID")
  
  # MODEL INDEX (TRESHOLDS 1 & 2) #
  Model_Index_D <- Trans_Spp %>% 
    group_by(Name,
             TaxonKey,
             Model_Index
    ) %>% 
    summarise(n_cells_spp = n()) %>% 
    select(-n_cells_spp)
  
  #____________ ESTIMATING DISTRIBUTION INDEX (TRESHOLD 3)_________ #
  # The number of species' cells present within each country's EEZ
  
  #Step 1.  Get EEZ id and Neighbour
  Neighbours_EEZ <- Neighbours %>% 
    group_by(EEZID,Country_Territory,Neighbour_Territory) %>% 
    summarise(n=n()) %>% 
    ungroup() %>% 
    select(-n)
  
  # Step 2. Determines the amount of grids present in each country
  Spp_Grid <- Trans_Spp %>% 
    group_by(TaxonKey,
             Model_Index, # Un-comment after producing models x datasets
             EEZID) %>% 
    summarise(n_spp_eez = length(unique(INDEX))) %>% 
    left_join(Neighbours_EEZ,
              by = "EEZID") %>% 
    filter(Country_Territory %in% Trans_Spp$Name, #Filter out unwanted Neighbours (those who don't have grids within but get included because they are Neighbours)
           Neighbour_Territory %in% Trans_Spp$Name)
  
  # Step 3. Sum total grids per Neighbours
  
  # Split dataframes to merge latter
  Country_Territory_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      Model_Index, # Un-comment after producing models x datasets
      TaxonKey,
      Name=Country_Territory,
      n_spp_eez
    )
  
  Neighbour_Territory_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      Model_Index,
      TaxonKey,n_spp_eez,
      Name=Neighbour_Territory, 
      Country_Territory
    )
  
  # Merge dataframes to get totals per Neighbourds
  Area_Index_D <- full_join(Country_Territory_T,
                            Neighbour_Territory_T, 
                            by = c("Model_Index","Name","TaxonKey")
  ) %>%
    rowwise() %>%
    mutate(Spp_Total = sum(n_spp_eez.x,n_spp_eez.y,na.rm=T)) %>% # Total gridcelles per Neighbours
    distinct() %>% # Removes false duplicates from `full_join()`
    rename(Neighbour_Territory = Name,
           n_spp_Country = n_spp_eez.x,
           n_spp_Neighbour = n_spp_eez.y) %>% 
    mutate(Area_Index = n_spp_Country/Spp_Total) %>%  #Estimates the proportion of grids per country
    select(1:3,6,8)
  
  #____________ FINAL INDEX TABLE_________ #
  Indexes <- Model_Index_D %>% 
    rename(Country_Territory = Name) %>% 
    full_join(Area_Index_D,
              by = c("TaxonKey","Country_Territory","Model_Index")
    ) %>% 
    filter(!is.na(Area_Index),
           !is.na(Model_Index) # Uncomment after producing Models x datasets
    )%>%  # Remove cases where the country does not pass the area_index and viceversa
    select(TaxonKey,Country_Territory,Neighbour_Territory,everything())
  
  ### Save spp dataframe
  
  if(nrow(Indexes) > 0 & Save == "Y"){
    
    File_Name <- paste(Spp,"_Transboundary.csv",sep = "")
    Save_Path <- paste(Results_Path,File_Name,sep="")
    
    write.csv(Indexes,
              Save_Path,
              row.names = F)
    
  }
  
  if(nrow(Indexes) == 0 & Save == "Y"){
    
    # Reads dataset of Non transboundary species
    Non_Transboundary_Data <- fread(paste(Results_Path,"Non_Transboundary_Data.csv",sep=""))
    
    # Get current Spp that is not transboundary 
    Current_Spp <- tibble(TaxonKey = Spp)
    
    # Combine new spp with others
    New_Non <- Non_Transboundary_Data %>% 
      bind_rows(Current_Spp)
    
    # Set a name for file and saves data
    New_Non_Name <- paste(Results_Path,"Non_Transboundary_Data.csv",sep="")
    write.csv(New_Non, New_Non_Name, row.names = F)
    
  }
  
  ### Function return
  
  EstTransIndex=Indexes # A dataframe with 
  
}
```

```{habitat_barplot, eval =F, echo =F}

Species_data <- Species_Trans %>% 
  mutate(scientific_name = paste(Genus,Species)) %>%
  left_join(Species_environ_list) %>% 
  mutate(DemersPelag = replace_na(DemersPelag, "Other")) %>% 
  mutate(Distance = ifelse(DemersPelag == "reef-associated", 1,
                           ifelse(DemersPelag =="pelagic-neritic",2,
                                  ifelse(DemersPelag == "demersal",3,
                                         ifelse(DemersPelag == "pelagic-oceanic",4,
                                                ifelse(DemersPelag =="benthopelagic",5,
                                                       ifelse(DemersPelag =="bathypelagic",6,
                                                              ifelse(DemersPelag =="bathydemersal",7,
                                                                     8)))))))
  ) %>% 
  group_by(DemersPelag,Distance) %>% 
  summarise(Countries_Genus = sum(n_countries,na.rm=T),
            Mean_Countries_Genus = mean(n_countries,na.rm=T),
            sd_Countries_Genus = sd(n_countries,na.rm=T),
            N_spp =length(unique(TaxonName))
  )

ggplot(Species_data,
       aes(
         x = reorder(DemersPelag,desc(Distance)),
         y = Mean_Countries_Genus,
         fill = Countries_Genus#,
         # colour = Countries_Genus
       )
) +
  geom_bar(stat = "identity") +
  # geom_errorbar(data = Species_data,
  #               aes(
  #                 x = reorder(DemersPelag,desc(Distance)),
  #                 ymin=Mean_Countries_Genus-sd_Countries_Genus, # mean +- 2*sd
  #                 ymax=Mean_Countries_Genus+sd_Countries_Genus
  #               ),
  #               colour = "black",
  #               width=.2,
  #               linetype = 2,
  #               size = 0.6,
  #               alpha = 0.5
  # ) +
  geom_text(data = Species_data, 
            aes(
              x = reorder(DemersPelag,desc(Distance)),
              y = 2,
              label = paste(as.character(N_spp), "species"),
            ),
            colour = "black"
  ) +
  coord_flip() +
  scale_fill_gradientn("Total number\nof countries",
                       colours = wes_palette("Zissou1"),
                       limits = c(0,1500),
                       breaks = seq(0,1500,250)
  ) +
  scale_colour_gradientn("Total number\nof countries",
                         colours = wes_palette("Zissou1"),
                         limits = c(0,1500),
                         breaks = seq(0,1500,250)
  ) +
  scale_y_continuous(breaks=seq(0, 40, 5), 
                     limits=c(0, 40)
                     )+
  labs(
    x = "Habitat type",
    y = "Mean number of countries per habitat"
  ) +
  ggtheme_plot()

```

```{r Territories_Circluar_Plot, eval = T, echo = T}

# -------------------------- #
# Data manipulation for plot
# -------------------------- #

# Set a number of 'empty bar' to add at the end of each group
Char <- as.factor(Countries_Data_Plot$group) # Set groups to factors
empty_bar <- length(unique(Countries_Data_Plot$group))
to_add <- data.frame( matrix(NA, empty_bar*nlevels(Char), ncol(Countries_Data_Plot)) )
colnames(to_add) <- colnames(Countries_Data_Plot)
to_add$group <- rep(levels(Char), each=empty_bar)
Countries_Data_Plot <- bind_rows(Countries_Data_Plot, to_add)
Countries_Data_Plot <- Countries_Data_Plot %>% arrange(group,value)
Countries_Data_Plot$id <- seq(1, nrow(Countries_Data_Plot))
 
# Get the name and the y position of each label

# Top n of each group label
Top_Countries <- Countries_Data_Plot %>% 
  group_by(group) %>% 
  top_n(5,value)

# Create labels for all but top 5
label_data <- Countries_Data_Plot 
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)

# Remove top 5
label_data_rest <- label_data %>% 
  filter(!individual %in% Top_Countries$individual)

# Create labels for top 5
Top_label_data <- label_data %>% 
  filter(individual %in% Top_Countries$individual)

# prepare a data frame for base lines
base_data <- Countries_Data_Plot %>% 
  group_by(group) %>% 
  summarize(start=min(id), 
            end=max(id) - empty_bar, 
            median = median(value, na.rm = T)
            ) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)))


# prepare a data frame for grid (scales)
grid_data <- base_data
grid_data$end <- grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1
grid_data$start <- grid_data$start - 1
grid_data[1,2] <- 5 # Manually include Africa for the median
grid_data[1,3] <- 1

# Median data
median_data <- grid_data %>% 
  mutate_at(vars(start,end),
            .funs = as.numeric)
 

# -------------------------- #
# Get id to Discrete data
# -------------------------- #

Discrete_Data_Plot <- Discrete_Data_Plot %>% 
  left_join(Countries_Data_Plot,
            by =c("individual","group")
  ) %>%
  mutate(value = ifelse(value.x <= -100,-100,value.x)) %>%
  select(individual,group,value,id) %>%
  arrange(group,value)

### make sure they have all same countries

Discrete_Data_Plot %>% 
  anti_join(Countries_Data_Plot,
            by = c("individual","group","id"))


# -------------------------- #
# Make the plot
# -------------------------- #


# Global Variables
Seq_axis <- seq(-100,100,20)
Plot_Limit <- max(Countries_Data_Plot$value,na.rm=T)
Plot_Limit_Low <- -110
Ticks_Color <- "grey50"

# Base plot
ggplot(Countries_Data_Plot,
       aes(x=as.factor(id), 
           y=value,
           fill=group)
) +       # Note that id is a factor. If x is numeric, there is some space between the first bar
  geom_bar(aes(x=as.factor(id),
               y=value,
               fill=group),
           stat="identity",
           alpha=0.5) +
  geom_bar(data = Discrete_Data_Plot,
           aes(x=as.factor(id),
               y=value),
           stat="identity",
           alpha=0.5) +
  # Add a val=100/75/50/25 lines. I do it at the beginning to make sur barplots are OVER it.
  geom_segment(data=grid_data, aes(x = end, y = 100, xend = start, yend = 100), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 80, xend = start, yend = 80), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 60, xend = start, yend = 60), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 40, xend = start, yend = 40), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 20, xend = start, yend = 20), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 0, xend = start, yend = 0), colour = "black", alpha=0, size=0.3 , inherit.aes = FALSE ) + # Cero
  geom_segment(data=grid_data, aes(x = end, y = -100, xend = start, yend = -100), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = -80, xend = start, yend = -80), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = -60, xend = start, yend = -60), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = -40, xend = start, yend = -40), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = -20, xend = start, yend = -20), colour = Ticks_Color, alpha=1, size=0.3 , inherit.aes = FALSE ) +
  # Add median lines for each gropup
  geom_segment(data=median_data,
               aes(x = end,
                   y = median,
                   xend = start+5, 
                   yend = median,
                   colour = group),
               alpha=1,
               size=0.5 , 
               inherit.aes = FALSE ) +
  # geom_hline(yintercept = Median_trans, colour = "black", alpha=1, size=0.3,linetype="dashed") + # All groups median
  # Add text showing the value of each line
  annotate("text", label = "Transboundary", x = 214, y = 45, size = 5, colour = "grey10", angle = 90) +
  annotate("text", label = "Discrete", x = 210, y = -45, size = 5, colour = "grey10", angle = 90) +
  annotate("text", 
           x = rep(max(Countries_Data_Plot$id),length(Seq_axis)),
           y = Seq_axis,
           label = c("<-100",as.character(Seq_axis)[2:(length(Seq_axis)-1)],">100"),
           color = Ticks_Color, 
           size= 4, 
           angle = 0, 
           # fontface="bold",
           hjust=1) +
  geom_bar(aes(x=as.factor(id),
               y=value,
               fill=group),
           stat="identity",
           alpha=0.5) +
  #Country labels
  geom_text(data=label_data_rest,
            aes(x=id, y=Plot_Limit,
                label=individual,
                hjust=hjust), 
            color="black",
            # fontface="bold",
            alpha=1,
            size=2.5,
            angle= label_data_rest$angle,
            inherit.aes = FALSE) +
  # Bold top 3 
  geom_text(data=Top_label_data,
            aes(x=id, y=Plot_Limit,
                label=individual,
                hjust=hjust), 
            color="black",
            fontface="bold",
            alpha=1,
            size=2.5,
            angle= Top_label_data$angle,
            inherit.aes = FALSE) +
  # Add base line information
  geom_segment(data=base_data, 
               aes(x = start, 
                   y = 0, 
                   xend = end, 
                   yend = 0
                   ), 
               colour = "black",
               alpha=0.8, 
               size=0.6 , 
               inherit.aes = FALSE) +
  ylim(Plot_Limit_Low,Plot_Limit) + # sets the circle the first value the central the last value how wide
  theme_minimal() +
  theme(
    # legend.position = c(0.5,0.5),
    legend.position = "",
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-1,4), "cm") 
  ) +
  coord_polar() + 
  scale_fill_manual("Continent",
                    values = c(wes_palette(n = 5, name = "Darjeeling1"),
                               wes_palette(n = 4, name = "Darjeeling2")
                    ),
                    na.value = "white"
  ) +
  scale_colour_manual("Continent",
                      values = c(wes_palette(n = 5, name = "Darjeeling1"),
                                 wes_palette(n = 4, name = "Darjeeling2")
                      ),
                      na.value = "white")

# Save plot

# ggsave(
#     plot = last_plot(),
#     width = 12,
#     height = 12,
#     units = "in",
#     filename = "Territory_circular_both.png",
#     path = "/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Figures/"
#   )
 

```

```{r Top_country_Circle_Diagram, eval =F, echo = F}

# Top 10 species

# Number of countries shared by each Species
Top_10_Countries <- Clean_Results_Trans %>% 
  filter(
         Area_Index < Min_AI |
         Area_Index > Max_AI,
         Model_Index == MI,
         Same_Nation == "No"
         ) %>% 
  group_by(Country_Territory) %>% 
  summarise(
    n_countries = length(unique(TaxonKey))
  ) %>% 
  top_n(10,n_countries)

# Countries that share the top 10
Top_Ten_Countries <- Clean_Results_Trans %>% 
  filter(
         Area_Index < Min_AI |
         Area_Index > Max_AI,
         Model_Index == MI,
         Same_Nation == "No",
         Country_Territory %in% Top_10_Countries$Country_Territory
         ) %>% 
  group_by(from=CT_fishing_entity,
           to=NT_fishing_entity
           ) %>% 
  summarise(value=n()
            ) %>% 
  ungroup() %>% 
  mutate(from = paste("F", from),
         to = paste("T", to)
         )

####________________###
# Circulize package ####
# https://jokergoo.github.io/circlize_book/book/
####________________###
  

# To set links collor 
Bins <- as.numeric(cut(Top_Ten_Countries$value,breaks = 5))

# Basic plot
circos.clear()
chordDiagram(Top_Ten_Countries, 
             annotationTrack = c("grid", "axis"), # keep grid and axis but not labels
             annotationTrackHeight = c(0.001, 0.05), # set links close to the axis
             directional = 1, # direction of arrows
             direction.type = c("diffHeight", "arrows"), # use arrows
             grid.col = "white",
             col = ifelse(Bins == 1,"#046C9A", # deep blue
                          ifelse(Bins == 2,"#78B7C5", #light blue
                                 ifelse(Bins == 3,"#EBCC2A", #yellow
                                        ifelse(Bins == 4, "#E1AF00", #cream
                                               "#F21A00")))), #red
             link.arr.col = wes_palette("Zissou1"),
             link.arr.type = "big.arrow",# make links big arrows
             diffHeight = uh(1, "mm"), # brings the arrow to the bottom of the source
             # annotationTrack = "grid", # no labels
             scale = FALSE, # fraction of total instead of absolute value
             preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(Top_Ten_Countries))))) # I have no idea but helps with the labels
    ) 
#  Rest of eddits
circos.track(track.index = 1, panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    xplot = get.cell.meta.data("xplot")
    ylim = get.cell.meta.data("ylim")
    sector.name = get.cell.meta.data("sector.index")
    
    circos.text(mean(xlim),
                ylim[1], 
                sector.name, 
                facing = "clockwise",
                niceFacing = TRUE,
                adj = c(-0.2, 0.5),
                col = "black")
    
}, bg.border = NA)



```