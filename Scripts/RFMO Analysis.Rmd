---
title: "RFMO Initial Analysis"
author: "Juliano Palacios-Abrantes"
date: '2019-02-04'
output: html_document
editor_options: 
  chunk_output_type: console
---


```{r setup, eval = T, echo=F, warning=F,message=F, results='hide'}

#### READ ME !!! ####
# Run this chunk before knit so you make sure you have all pkgs installed in R

ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE,repos = "http://cran.us.r-project.org")
  sapply(pkg, require, character.only = TRUE)
}


#### Library ####
packages <- c(
  "readxl", # Read dataframe
  "data.table", # Read dataframe (Fast!)
  "dplyr", # Data manipulation
  "tidyr", # Data manipulation
  "ggplot2", #Nice grpahs and spatial analysis
  "wesanderson",
  "circlize", # For circular plot
  "EBImage", #for reading images to the circular plot
  # "cowplot",
  # "rgdal",
  # "RColorBrewer",
  # "knitr",
  # "kableExtra",
  "ggrepel", # for nice plot labels
  "ggsflabel", # for nice sf_plots labels
  # "gridExtra",
  # "ggmap",
  # "rgeos",
  # "stringr",
  # "stringer",
  "spdep", # for poly2nb
  "sf", #Spatial analysis 
  "sp", #Spatial analysis 
  "purrr",#Spatial analysis
  "rgdal", #Spatial analysis
  "tools", #Spatial analysis 
  # "png", # For reading plots in chunk codes
  # "grid" # For reading plots in chunk codes
  "parallel", # for parallelization
  "taxize", # For getting species names
  "rfishbase" # for species ecosystem affinity
)

ipak(packages)

ggtheme_map <- function(base_size = 9, Region = "NA") {
  
  theme(text             = element_text(#family = "Helvetica",
    color = "gray30", size = base_size),
    plot.title       = element_text(size = rel(1.25), hjust = 0, face = "bold"),
    panel.background = element_blank(),
    panel.border     = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(color = "transparent"),
    strip.background =element_rect(fill = "transparent"),
    strip.text.x = element_text(size = 18, colour = "black",face= "bold.italic", angle = 0),
    axis.line        = element_blank(), # element_line(colour = "grey30", size = .5))
    axis.ticks       = element_blank(),
    axis.text        = element_blank(),
    axis.title       = element_blank(),
    legend.key       = element_rect(colour = NA, fill = NA, size = 4),
    legend.position = "bottom",
    legend.key.width =unit(6,"line")
  )
}

ggtheme_plot <- function() {
  theme(
    plot.title = element_text(size = rel(1), hjust = 0, face = "bold"),
    panel.background = element_blank(),
    strip.background = element_blank(),
    # strip.text       = element_text(size = base_size, face = "italic"),
    panel.border     = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_blank(),
    axis.ticks = element_blank(),
    axis.text.x = element_text(size = 12,
                               angle = 0,
                               face = "plain"),
    axis.text.y = element_text(size = 12),
    axis.title = element_text(size = 14),
    legend.key = element_rect(colour = NA, fill = NA),
    legend.position  = "right",
    legend.title = element_text(size = 14),
    legend.text = element_text(size = 12),
    strip.text.x = element_text(size = 12, colour = "black"),
    strip.text = element_text(size = 12)
  )
}

#### Set paths for computer ####


# Set paths depending on machine Beast (jepa88), "carmelia" or Hall1000
if(Sys.info()[7] == "jepa88"){
  Data_Path <- "Z:/JULIANO_NEYMAR/FishForVisa/"
  }
if(Sys.info()[7] == "carmelia"){
  Data_Path <- paste(here::here(),"/Temporal_Data", sep ="")
}
if(Sys.info()[7] == "hall1000"){
  Data_Path <- "/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/"
}

# Setting up paths 
# If path exists overrite it, otherwise creats a new path for that year

# Path for saving Results
Results_Path = paste(Data_Path,"Results/",sep = "")
if(file.exists(Results_Path) == TRUE){
  Results_Path = paste(Data_Path,"Results/",sep = "")
}else{
  dir.create(paste(Data_Path,"Results/",sep = ""))
  Results_Path = paste(Data_Path,"Results/",sep = "")
}

# Path for saving Figures
Figures_Path = paste(Data_Path,"Figures/",sep = "")

if(file.exists(Figures_Path) == TRUE){
  Figures_Path = paste(Data_Path,"Figures/",sep = "")
}else{
  dir.create(paste(Data_Path,"Figures/",sep = ""))
  Figures_Path = paste(Data_Path,"Figures/",sep = "")
}

### Message for my brain

print("_____________________ WARNING DO NOT FORGET TO PULL/PUSH BEFORE YOU START_____________________")

```


# Methods

These are the methods to follow:

1. Determine which countries have Neighbouring EEZs  
  1.1. For this we used the Marine regions EEZ maps (We have to change this because it does not discriminate by oceans and we need this) and a routine to identify Neighbouring polygons,
  1.2. Then we match the DBEM spatial information (e.g. INDEX within EEZ and coordinates) with the Neighbouring data
2. Overlap distribution maps with Neighbours data  
  2.1. For each species we merged the DBEM_Neighbours data with their known distribution (Gab's data)  
3. Determine transboundary if:  
  3.1. Species is present in both Neighbouring EEZs by INDEX  

Alternatively, we could create a "confidence level" based on a ratio, i.e;
- How many grid cells of both the EEZs is the species present on. A species that covers all cells would have 100% but a species that covers, lets say, all of EEZ1 but only half of EEZ2 would be 75%.  
- Another option is to have the index based on the species distribution. That is to say, what proportion of the total species distribution actually falls within both EEZs....


### Current issues

- How to distinguish between North and South? Example of Brazil, Uruguay and French Guyana

## Data

```{r Speceis_List_For_Data, eval = F, echo = T}

# Get the DBEM list of species to extract from other modesl
#GFDL
DBEM_species_G <- data_frame(TaxonKey = list.files("/Volumes/DATA/DATA/DBEM/GFDL26F1"))
#IPSL
DBEM_species_I <- data_frame(TaxonKey = list.files("/Volumes/DATA/DATA/DBEM/IPSL26F1"))
#MPI
DBEM_species_M <- data_frame(TaxonKey = list.files("/Volumes/DATA/DATA/DBEM/MPI26F1"))


# Merge the, and save to send to gabs

DBEM_Species_List <- DBEM_species_I %>% 
  bind_rows(DBEM_species_G,
            DBEM_species_M) %>% 
  group_by(TaxonKey) %>% 
  summarise() %>% 
  filter(str_detect(TaxonKey, "^6"))


# Include species name, as well... 

exploited_species <- read.csv("/Volumes/DATA/PROJECTION exploited species ENM/exploited_species_list.csv")

DBEM_Species_List <- DBEM_Species_List %>% 
  left_join(exploited_species,
            by ="TaxonKey")


# write.csv(DBEM_Species_List,
#           "DBEM_Species_List.csv",
#           row.names = F)

### Check Gabs Data ####

# Does all data have the same number of files?

# SAU <- length(list.files("/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Distribution_Data/SAU_Distribution/"))
# ENM <- length(list.files("/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Distribution_Data/ENM/"))
# Occ <- length(list.files("/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Distribution_Data/Occurence/"))

####### Yes they do! ####

#### List of species we have data for...

# Removes everything before the number
Step_One <- gsub(".*_","",list.files("/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Distribution_Data/SAU_Distribution/"))

# Species List
Species_List <- gsub("\\..*","",Step_One)


# Get All SAU species for the final analysis



```

## Sub Routine Estimating Neighbourds

### Functions `EstNeighbours`

This function determines what EEZs are Neighbours and returns a data.frame of it

```{r funEstNeighbours, eval = F, echo=T}
# Determine which countries are Neighbours

EstNeighbours <- function(Shapefile, Partial = "NA"){
  
  # Get sparse matrix
  int = suppressMessages(st_intersects(Shapefile))
  # Warnning message
  # although coordinates are longitude/latitude, st_intersects assumes that they are planar

  
  # Intitalize new object
  mat = NULL
  
  # Fill
  for(i in 1:NROW(int)){
    #Create matrix with ID and intersecting IDs
    tmp = cbind(i, int[[i]])
    
    # Join to Initalized object
    mat  = rbind(mat, tmp)
  }
  
  # Build final data.frame substituting ID for name (in this case nc$name)
  Result_table = data.frame(Name = Shapefile$Name[mat[,1]], 
                            Neighbour_Territory = Shapefile$Name[mat[,2]]
  )
  
  # Remove duplicates... eg of course an object intersects with itself...
  Result_table = Result_table[Result_table$Name != Result_table$Neighbour_Territory,]
  
  if(Partial == T){
    # If only partial analysis just returns Neighbour list
    return(Result_table)
    
  }else{
  # Merge them with SAU data
  suppressWarnings(
    # warning for characters in name, no problem
  DBEM_Neighbours_Data <- Result_table %>% 
     left_join(EEZIDs_List, 
              by = "Name") %>% # Asign EEZ id to each country
    left_join(EEZ_CellID, 
              by = "EEZID") %>% # Asign EEZ id to each country
    left_join(Coor,
              by = "INDEX") %>%  # Inclu
    rename(Country_Territory = Territory)
  
  )
  
  return(DBEM_Neighbours_Data)
  
  } # end ifelse
} # end function


# subset <- World_EEZs %>% filter(Name %in% c("Chile","Peru"))
# EstNeighbours(subset)
# EstNeighbours(subset,T)

```

### Sub Routine; Neighbours

#### EEZ

```{r EEZ_Neighbourds_Control_Pannel, eval = F, echo = F}

#### Load Data Needed ####

# Spatial analysis for Countries boundaries from marine regions ####

###_______________________________Read Me_____________________________________________#
#### Data License and references ###
# Marine Regionsâ€™ data is licensed under CC-By-NC-SA (https://creativecommons.org/licenses/by-nc-sa/4.0/).
# Flanders Marine Institute (2018). Maritime Boundaries Geodatabase: Maritime Boundaries and Exclusive Economic Zones (200NM), version 10. Available online at http://www.marineregions.org/. https://doi.org/10.14284/312

#### Using the SAU shapefile that contains EEZ per ocean (E.G. Mexico Pacific and Mexico Atlantic)
###________________________________________________________________________________#

# SAU shapefile

# The path
path_world <- paste(Data_Path,"Spatial_Data/SAU_Shapefile",sep="")
# #The File
fnam_world <- "SAUEEZ_July2015.shp"
# #Load it!
# 
World_EEZs <- st_read(dsn = path_world,
                      layer =file_path_sans_ext(fnam_world))

#### Grid cell information ####

# List of DBEM INDEX within the EEZ 
#Data provided by Vicki Lam

EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))
EEZ_CellID <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/EEZ_CellID.xlsx",sep=""))

colnames(EEZ_CellID) <- c("EEZID","INDEX")

# DBEM Coordinate system
Coor <- fread(paste(Data_Path,"Spatial_Data/Lon_Lat_DBEM.txt",sep=""),header = FALSE)
colnames(Coor) <- c("INDEX","Longitude","Latitude")


# Run Function (Ran and saved May 27 2019 at 6pm)
 system.time(
  EEZ_Neighbour_List <- EstNeighbours(World_EEZs, Partial = F)
 )
# 8203.05    0.25 8204.51 (around 2 hours 30 min)

# user  system elapsed 
# 291.53  238.73  530.73 (SO MUCH FASTER!)
 
write.csv(EEZ_Neighbour_List,
          paste(Data_Path,"Spatial_Data/EEZ_Neighbour_List.csv", sep =""),
          row.names = F)



####_________________________________________ TESTING PERIOD_________________________________________####
# I'm substetting central america to do the whole analysis (smaller EEZs = faster computation) once I have figure out things I'll run for all

### Data
# For now using only the subdata

## Spatial Test Data
# SAU_Regions <- as.data.frame(unique(World_EEZs$Name))

# Test_Countries <-c("Guatemala (Caribbean)","Guatemala (Pacific)","Belize","Honduras (Pacific)","El Salvador","Costa Rica (Pacific)","Costa Rica (Caribbean)", "Panama (Caribbean)", "Panama (Pacific)")

# Test <- World_EEZs[World_EEZs@data$Name %in% Test_Countries, ]

```

#### RFMO

```{r RFMO_Index, eval = F, echo = F}

#### Load Data Needed ####

# SAU RFMO shapefile

# The path
path_world <- paste(Data_Path,"/Spatial_Data/","RFMO","/SAU_RFMO",sep="")
# #The File
fnam_world <- "SAU_RFMO_Sept_2015.shx"
# #Load it!
# 
RFMOs_sf <- st_read(dsn = path_world,
                      layer =file_path_sans_ext(fnam_world)) %>% 
  dplyr::rename(Name = RFMO_nm_s) %>% 
  st_set_crs(3832) %>% # Making sure is same proyection
  st_transform(3832) # to match shapefiles

###
head(RFMOs_sf)
tail(RFMOs_sf)

IPHC <- RFMOs_sf %>% 
  filter(Name == "IPHC") %>% 
  st_simplify(preserveTopology = TRUE, dTolerance = 100)


ggplot(IPHC) +
  geom_sf() +
  facet_wrap(~OBJECTID)

head(IPHC)

Test <- RFMOs_sf %>% 
  group_by(OBJECTID, Name) %>% 
  st_combine()

ggplot(Test) +
  geom_sf()


# Load coordinate system

Coor <- fread(paste(Data_Path,"Spatial_Data/Lon_Lat_DBEM.txt",sep=""),header = FALSE)
colnames(Coor) <- c("INDEX","Longitude","Latitude")

# COnvert Coor system to sf
Coor_sf = st_as_sf(Coor,
                        coords = c("Longitude", "Latitude")) %>% 
  st_set_crs(3832) %>% # to match shapefiles
  st_transform(3832) # to match shapefiles

# Merge RFMO and coor datasets
RFMO_Coor <- st_join(RFMOs_sf,
                         Coor_sf,
                         join = st_contains) %>% 
  filter(!is.na(INDEX)) # Remove regions beyond RFMOs
  
# head(RFMO_Coor)

# Convert it back to a data frame and select only the two columns we want
RFMO_INDEX <- as.data.frame(RFMO_Coor) %>% 
  select(INDEX,Name) %>% 
  arrange(INDEX)

# head(RFMO_INDEX)

# Save new data
write.csv(RFMO_INDEX,
          paste(Data_Path,"Spatial_Data/RFMO/RFMO_INDEX.csv",sep=""),
          row.names = F
          )

# Map it (works!)

# RFMO_INDEX %>%
#   left_join(Coor,
#             by = "INDEX") %>%
#   ggplot(.,
#             aes(x = Longitude,
#                 y = Latitude,
#                 color = Territory,
#                 fill = Territory)
#             ) +
#   geom_tile() 
# 
# 
# RFMO_INDEX %>%
#   left_join(Coor,
#             by = "INDEX") %>%
#   ggplot(.,
#             aes(x = Longitude,
#                 y = Latitude,
#                 color = INDEX,
#                 fill = INDEX)
#             ) +
#   geom_tile() +
#   facet_wrap(~Territory)

```

```{r RFMO_Neighbourds_Control_Pannel, eval = F, echo = F}

#### Load Data Needed ####

# SAU RFMO shapefile

# The path
path_world <- paste(Data_Path,"Spatial_Data/SAU_RFMO",sep="")
# #The File
fnam_world <- "SAU_RFMO_Sept_2015.shx"
# #Load it!
# 
RFMOs_sf <- st_read(dsn = path_world,
                      layer =file_path_sans_ext(fnam_world)) %>% 
  dplyr::rename(Name = RFMO_nm_s)



# Run Function (Ran and saved May 27 2019 at 6pm)
 system.time(
  RFMO_Neighbour_List <- EstNeighbours(RFMOs_sf, Partial = T)
 )
# 8203.05    0.25 8204.51 (around 2 hours 30 min)
 
 
 ## Include Index column
 
RFMO_Neighbour_List <- fread(paste(Data_Path,"Spatial_Data/RFMO/RFMO_Neighbour_List.csv",sep=""),header = TRUE) %>% 
  left_join(RFMO_INDEX,
            by = "Name") %>% 
  rename(Territory = Name,
         Neighbour = Neighbour_Territory) 

# head(RFMO_Neighbour_List)


write.csv(RFMO_Neighbour_List,
          paste(Data_Path,"Spatial_Data/RFMO_Neighbour_List.csv", sep =""),
          row.names = F)

```


### Estimate Transboundary Species

#### Function `GetSppDist`

This function Read in species distribution from the observation data, ESM models and SAU data, still missing DBEM

```{r GetSppDist, eval = T, echo = T}

#### The function
# NOTES
# For now we're using only the last 10 years average, basicaaly if the species has been fished in any of these years, its considered present

GetSppDist=function(Spp,Model,Coord){
  
  Distpath <- paste(Data_Path,"Distribution_Data/",sep="")
  INDEX = seq(1,259200,1)
  # INDEX <- Coordinates$INDEX
  
  # SAU Distributions
  if(Model == "SAU_D"){
    File_Name <- paste("SAU_Distribution/DIST_GOOD_SP_")
  }
  
  # SAU Catch
  if(Model == "SAU_C"){
    File_Name <- paste("SAU_data_per_species/CATCH_SP_")
  }
  
  # Occurence
  if(Model == "Occ"){
    File_Name <- paste("Occurence/OCCURENCE_JULIANO_")
  }
  
  # ENM Model
  if(Model == "ENM"){
    File_Name <- paste("ENM/ENM_JULIANO_")
  }
  
  # DBEM Data
  # if(Model == "DBEM"){
  #   Distpath <- "/Volumes/DATA/JULIANO_NEYMAR/PristineSeasData
  #   Final_Path <- "ENM"
  #   File_Name <- paste("ENM_JULIANO",Spp,".mat",sep="")
  # }
  
  if(Model == "All"){
    
    Models_List <- c(paste(Distpath,"SAU_Distribution/DIST_GOOD_SP_",Spp,".mat",sep =""),
                     paste(Distpath,"Occurence/OCCURENCE_JULIANO_",Spp,".mat",sep=""),
                     paste(Distpath,"ENM/ENM_JULIANO_",Spp,".mat",sep="")
                     )
    
    # Jumps species not modeled. NOTE: We only need one as ENM, Occ and SAU Dis have all the same 939 spp
    if(file.exists(Models_List[1])){
    
    Load <- lapply(Models_List, FUN=R.matlab::readMat, na.strings=0)
     
    sppdist <- as.data.frame(bind_cols(Load)) %>% 
      mutate(
        INDEX = INDEX,
        TaxonKey = Spp
      )
    colnames(sppdist) <- c("SAU_D","Occ","ENM","INDEX","TaxonKey")
    
    #### Step for SAU catch data that has to be averaged
    File_Name <- paste("SAU_data_per_species/CATCH_SP_")
    SppPath <- paste(Distpath,File_Name,Spp,".mat",sep="")
    
    # For now we're using only the last 10 years average, basicaaly if the species has been fished in any of these years, its considered present
    SAU_C_data <- as.data.frame(R.matlab::readMat(SppPath)) %>% 
      select(CATCH.1:CATCH.65) %>% 
      mutate(INDEX = INDEX) %>% 
      gather("Year","Catch",1:10) %>% # Last 10 years of data
      group_by(INDEX) %>% 
      summarise(SAU_C = mean(Catch,na.rm=T))
    
    # Join both tables
    sppdist <- sppdist %>% 
      left_join(SAU_C_data,
                by = "INDEX") %>% 
      select(TaxonKey,INDEX,everything()) %>% 
      left_join(CoorG,
                by = "INDEX")
    
    # Fix coordinate system incompatibility between Gab and DBEM
    sppdist <- suppressWarnings(sppdist[order(sppdist$Latitude, rev(sppdist$Longitude),decreasing=TRUE), ] %>% 
      mutate(INDEX = seq(1,259200,1)) %>% 
      gather("Model","Value",3:6) %>%
      mutate(Value = ifelse(is.na(Value), 0, Value)) # Converting NA's to ceros
    )
    
    getSppDist = sppdist
    
    }else{
      
      # print(paste("No info for this species"))
    }
    
  }else{  
    
    # Merge paths
    SppPath <- paste(Distpath,File_Name,Spp,".mat",sep="")
    
    if(file.exists(SppPath) == TRUE){
      
    #Install (if needed) R.matlab package
    if(!require(R.matlab)){
      install.packages("R.matlab")
    }
    
    # Read Files
    
    sppdist <- as.data.frame(R.matlab::readMat(SppPath)) %>% 
      mutate(INDEX = INDEX,
             Species = Spp) %>% 
      left_join(Coord) 
    
    # Fix coordinate system incompatibility between Gab and DBEM
    sppdist <- sppdist[order(sppdist$Latitude, rev(sppdist$Longitude),decreasing=TRUE), ] %>% 
      mutate(INDEX = seq(1,259200,1))
   
   # Return 
    getSppDist=sppdist
    
    }else{
    print(paste("No info for this species",Spp, "in",Model))
  }
  
  }
}

#______ Test ______#

# Variables outside function
# head(GetSppDist(600004,"SAU_D")) # Works
# head(GetSppDist(600004,"SAU_C")) # Works
# head(GetSppDist(600004,"Occurence")) # Works
# head(GetSppDist(600004,"ENM")) # Works
# head(GetSppDist(600004,"All")) # Works


```

#### Function `EstTransIndex`

##### NOTES:

###### General:
- For now using SAU_C as presence absence
- Grouping by species distribution within EEZ and not EEZ area

###### Tresholds:
###### Model Index, line ~479

This first treshold estimates the uncertanty of models. Goes from 0 - 1 as follows:

- 1 or 0; All models agree that in the presence of the species
- 0.75; Three out of four models agree on speices presence
- 0.50; Two out of four models agree on speices presence
- 0.25; Only one model flags a speices presence
- 0; All models agree there is no species there

** NOTE THAT THE FUNCTION IS SETTED TO OUTPUT RESULTS FOR LL MODELS **

###### Distribution Index, line ~482

```{r Trans_Spp_Function, eval= T ,echo = T,warning = F,message = F}

# Function to determine whether or not a species is transboundary

# Varibales needed
# Spp: Species to be analized, data with presence/absence per gridcell
# Index_EEZ: Reference list of all INDEX that fall within EEZs
# EEZ_Size: Number of grid-cells that each EEZ has
# Neighbours: Reference list of neighbouring countries

# Needs getSppDist

#### For testing 
#Spp <- 600004  # Anchovie Equator, Chile and Peru
# Spp <- 600107 # Tuna Many RFMOs
#Model <- "All"
#Coord = CoorG

# For EEZ
# Neighbours <- Neighbours_Data
# Index_Code <- Index_Code
 
 # For RFMO 
 # Index_Code <- RFMO_INDEX
 # Neighbours <- RFMO_Neighbor_List %>% 
 #   rename(Territory = Name,
 #         Neighbour = Neighbor_Territory)
 
 
# __________________________________
# __________________________________

# The function
EstTransIndex <- function(Spp,Model,Neighbours,Coord,Index_Code,Save="Y",Jurisdiction_Type,Catch = "N"){
  
  # Get model data from spps
  SppDist <- GetSppDist(Spp,Model,Coord)
  
  # Result 1. Number of Countries that share the species
  
  #____________ ESTIMATING MODEL INDEX (TRESHOLD 1)_________ #
  Trans_Spp <- SppDist %>%
    filter(INDEX %in% Neighbours$INDEX,# Filter data only located within EEZs
           Model != "SAU_C") %>% # Only using observational and modelled data
    mutate(Value = ifelse(Value > 0, 1,0)) %>%  
    filter(Value > 0) %>%
    group_by(TaxonKey,
             INDEX
    ) %>%
    summarise(Model_Index = mean(Value,na.rm=T)
    ) %>%
    filter(Model_Index > 0) %>%
    # ____________ ESTIMATING FUNDAMENTAL NICHE (TRESHOLD 2)_________ #
    left_join(SppDist,
              by = c("TaxonKey","INDEX")) %>%
    filter(Model == "SAU_C", # Only keeping cells where SAU catch exists
           Value > 0) %>%
    mutate(Model_Index = Model_Index*100) %>%
    select(-Model, -Value, -Latitude,-Longitude) %>%
    left_join(Index_Code,
              by = "INDEX")
  
  # MODEL INDEX (TRESHOLDS 1 & 2) #
  Model_Index_D <- Trans_Spp %>% 
    group_by(Territory,
             TaxonKey,
             Model_Index
    ) %>% 
    summarise(n_cells_spp = n()) %>% 
    select(-n_cells_spp)
  
  #____________ ESTIMATING DISTRIBUTION INDEX (TRESHOLD 3)_________ #
  # The number of species' cells present within each country's EEZ
  
  #Step 1.  Get EEZ id and Neighbour
  Neighbours_List <- Neighbours %>% 
    group_by(Territory,Neighbour) %>% 
    summarise(n=n()) %>% 
    ungroup() %>% 
    select(-n)
  
  # Step 2. Determines the amount of grids present in each country
  Spp_Grid <- Trans_Spp %>% 
    group_by(TaxonKey,
             Model_Index, # Un-comment after producing models x datasets
             Territory) %>% 
    summarise(n_spp_eez = length(unique(INDEX))) %>% 
    left_join(Neighbours_List,
              by = "Territory") %>% 
    filter(Territory %in% Trans_Spp$Territory, #Filter out unwanted Neighbours (those who don't have grids within but get included because they are Neighbours)
           Neighbour %in% Trans_Spp$Territory)
  
  # Step 3. Sum total grids per Neighbours
  
  # Split dataframes to merge latter
  Territory_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      Model_Index, # Un-comment after producing models x datasets
      TaxonKey,
      Name=Territory,
      n_spp_eez
    )
  
  Neighbour_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      Model_Index,
      TaxonKey,n_spp_eez,
      Name=Neighbour, 
      Territory
    )
  
  # Merge dataframes to get totals per Neighbourds
  Area_Index_D <- full_join(Territory_T,
                            Neighbour_T, 
                            by = c("Model_Index","Name","TaxonKey")
  ) %>%
    rowwise() %>%
    mutate(Spp_Total = sum(n_spp_eez.x,n_spp_eez.y,na.rm=T)) %>% # Total gridcelles per Neighbours
    distinct() %>% # Removes false duplicates from `full_join()`
    rename(Neighbour = Name,
           n_spp_Country = n_spp_eez.x,
           n_spp_Neighbour = n_spp_eez.y) %>% 
    mutate(Area_Index = n_spp_Country/Spp_Total) %>%  #Estimates the proportion of grids per country
    select(1:3,6,8)
  
  #____________ FINAL INDEX TABLE_________ #
  Indexes <- Model_Index_D %>% 
    # rename(Territory = Name) %>% 
    full_join(Area_Index_D,
              by = c("TaxonKey","Territory","Model_Index")
    ) %>% 
    filter(!is.na(Area_Index),
           !is.na(Model_Index) # Uncomment after producing Models x datasets
    ) %>%  # Remove cases where the country does not pass the area_index and viceversa
    select(TaxonKey,Territory,Neighbour,everything())
  
  
  ### Save spp dataframe
  
  if(nrow(Indexes) > 0 & Save == "Y"){
    
    File_Name <- paste(Spp,"_Transboundary.csv",sep = "")
    Save_Path <- paste(Results_Path,"/Trans_Results/",File_Name,sep="")
    
    write.csv(Indexes,
              Save_Path,
              row.names = F)
    
  }
  
  if(nrow(Indexes) == 0 & Save == "Y"){
    
    # Reads dataset of Non transboundary species
    Non_Transboundary_Data <- fread(paste(Results_Path,"/Trans_Results/Non_Transboundary_Data.csv",sep=""))
    
    # Get current Spp that is not transboundary 
    Current_Spp <- tibble(TaxonKey = Spp)
    
    # Combine new spp with others
    New_Non <- Non_Transboundary_Data %>% 
      bind_rows(Current_Spp)
    
    # Set a name for file and saves data
    New_Non_Name <- paste(Results_Path,"/Trans_Results/Non_Transboundary_Data.csv",sep="")
    write.csv(New_Non, New_Non_Name, row.names = F)
    
  }
  
  ### Get Specie's catch
    
Catch_Data <- SppDist %>%
  filter(INDEX %in% Neighbours$INDEX,# Filter data only located within EEZs
           Model == "SAU_C",
         Value > 0) %>%
  left_join(Index_Code,
            by ="INDEX") %>% 
  group_by(TaxonKey,Territory) %>% 
  summarise(Total_Catch = sum(Value,na.rm=T))

  ### Save Catch data

 if(nrow(Catch_Data) > 0 & Catch == "Y"){
    
    File_Name <- paste(Spp,"_Catch.csv",sep = "")
    Save_Path <- paste(Results_Path,"/Catch_Results/",File_Name,sep="")
    
    write.csv(Catch_Data,
              Save_Path,
              row.names = F)
    
  }
  
  ### Function return
  
  EstTransIndex=Indexes # A dataframe with 
  
}

# __________________________________
# Test function
# __________________________________
# EstTransIndex(Spp = 600004,
 #              Mode = "All",
  #             Neighbours = Neighbours_Data,
   #            Coord = CoorG,
    #           Index_Code=Index_Code,
     #          Jurisdiction_Type = "EEZ",
      #         Save="Y",
       #        Catch = "Y")

  
# Spp <-  # Tuna Many RFMOs
# Model <- "All"
# Coord = CoorG
# 
# # For EEZ
#  # Neighbours <- Neighbours_EEZ
#  # Index_Code <- EEZ_Index_Code
#  
#  # For RFMO 
#  Index_Code <- RFMO_INDEX
#  Neighbours <- RFMO_Neighbor_List %>% 
#    rename(Territory = Name,
#          Neighbour = Neighbor_Territory)


```

#### Function 'Mclapply_Hack'

```{r Mclapply_Hack_Fun, eval= T , echo = T, warning = F, message = F}

# The hack
# https://www.r-bloggers.com/implementing-mclapply-on-windows-a-primer-on-embarrassingly-parallel-computation-on-multicore-systems-with-r/

Mclapply_Hack <- function(...){
    ## Create a cluster
    size.of.list <- length(list(...)[[1]])

    cl <- makeCluster(min(size.of.list, n_cores))
    
  ## Find out the names of the loaded packages 
    loaded.package.names <- c(
        ## Base packages
        sessionInfo()$basePkgs,
        ## Additional packages
        names(sessionInfo()$otherPkgs))
    tryCatch( {

       ## Copy over all of the objects within scope to
       ## all clusters. 
       this.env <- environment()
       while( identical( this.env, globalenv() ) == FALSE ) {
           clusterExport(cl,
                         ls(all.names=TRUE, env=this.env),
                         envir=this.env)
           this.env <- parent.env(environment())
       }
       clusterExport(cl,
                     ls(all.names=TRUE, env=globalenv()),
                     envir=globalenv())
       
       ## Load the libraries on all the clusters
       ## N.B. length(cl) returns the number of clusters
       parLapply( cl, 1:length(cl), function(xx){
           lapply(loaded.package.names, function(yy) {
               require(yy , character.only=TRUE)})
       })
       
       ## Run the lapply in parallel 
       return( parLapply( cl, ...) )
    }, finally = {        
       ## Stop the cluster
       stopCluster(cl)
    })


## Warn the user if they are using Windows
if( Sys.info()[['sysname']] == 'Windows' ){
    message(paste(
      "\n", 
      "   *** Microsoft Windows detected ***\n",
      "   \n",
      "   For technical reasons, the MS Windows version of mclapply()\n",
      "   is implemented as a serial function instead of a parallel\n",
      "   function.",
      "   \n\n",
      "   As a quick hack, we replace this serial version of mclapply()\n",
      "   with a wrapper to parLapply() for this R session. Please see\n\n",
      "     http://www.stat.cmu.edu/~nmv/2014/07/14/implementing-mclapply-on-windows \n\n",
      "   for details.\n\n"))
}

## If the OS is Windows, set mclapply to the
## the hackish version. Otherwise, leave the
## definition alone. 
mclapply <- switch( Sys.info()[['sysname']],
   Windows = {Mclapply_Hack}, 
   Linux   = {mclapply},
   Darwin  = {mclapply})

}
## end mclapply.hack.R

```


## Principal Routine

#### Control Pannel

```{r EEZ_Control_Pannel, eval = T, echo = F}

# Set Jurisdiction to EEZ or RFMO
Jurisdiction <- "RFMO"

# Updates result's path for the jurisdiction
Results_Path <- paste(Results_Path,Jurisdiction,"/",sep="")

# Removes everything before the number
Step_One <- gsub(".*_","",list.files(paste(Data_Path,"/Distribution_Data/SAU_Distribution/",sep="")))

# Species List
Species_List <- gsub("\\..*","",Step_One)

# Set Spceies list
Exploited_Species <- fread(paste(Data_Path,"Distribution_Data/exploited_species_list.csv",sep="")) %>%
  filter(TaxonKey %in% Species_List)

# Step to run function for species not computed
Computed_Spp <- as.integer(gsub("\\_.*","",list.files(Results_Path)))

Exploited_Species <- Exploited_Species %>%
  filter(!TaxonKey %in% Computed_Spp)

# Gabriel's coordinate system
CoorG <- read.csv(paste(Data_Path,"Spatial_Data/coordinates_gab.csv",sep="")) %>%
  mutate(INDEX = seq(1,259200,1))

# For Function
Exploited_Species_List <- Exploited_Species$TaxonKey

# Load Jursidiction-dependant data
if(Jurisdiction == "EEZ"){
  # Load neighbours data from previouse routine
  Neighbours_Data <- fread(paste(Data_Path,"Spatial_Data/EEZ_Neighbours_List.csv", sep =""))
  
  # SAU relations between INDEX and Country's EEZs
  EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))
  EEZ_CellID <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/EEZ_CellID.xlsx",sep=""))
  colnames(EEZ_CellID) <- c("EEZID","INDEX")
  
  Index_Code <- EEZIDs_List %>% 
    left_join(EEZ_CellID) %>% 
    rename(Territory = Name)
  
}else{
  
  # Load neighbours data from previouse routine
  Neighbours_Data <- fread(paste(Data_Path,"Spatial_Data/RFMO/RFMO_Neighbours_List.csv", sep =""))
  
  Index_Code <- fread(paste(Data_Path,"Spatial_Data/RFMO/RFMO_Index_Code.csv", sep =""))
  
}

head(Neighbours_Data)
# Creates dummy dataset for Non transboundary species
write.csv(tibble(TaxonKey = "NA"), paste(Results_Path,"Trans_Results/Non_Transboundary_Data.csv",sep=""), row.names = F)

# Number of cores to us 
n_cores <- detectCores()

# Just a warning for me not to forget
print(paste("You are running the model for",nrow(Exploited_Species),"Species at the",Jurisdiction,"level"))
```

#### Run Routine
```{r Routine_parallel, eval = F, echo = F}


# Run model in parallel
system.time(
  Spp_Trans <- bind_rows(
    mclapply(
      Exploited_Species_List,
      FUN = EstTransIndex,
      Model = "All", # all data sources
      Neighbours = Neighbours_Data,
      Coord = CoorG,  # Gabriels coordinate system for read species dist
      Index_Code = Index_Code, 
      Save = "Y",  # For saving
      Catch = "N",
      Jurisdiction_Type = Jurisdiction # For saving in proper path
    )
  )
)

# Data on time for the Beast with 30 cores
# user   system  elapsed 
 #8117.72  1991.91 10296.00 
    
   
```

## Sub Routine; SAU Catch

###`getSAucat` 

```{r getSAUCatch, eval = F, echo = F}

# Function to get sau Catch data and total per country over a mean of (standarized 10 years )
getSAUCatch <-function(TaxonKey, Coord, nyears = 10){
  suppressMessages(

  year <- 67-nyears-1  
    
Catch_Data <- GetSppDist(TaxonKey,Model="SAU_C",Coord = Coord) %>% 
  select(year:67) %>% 
  gather("Year","Catch",1:nyears) %>% 
  filter(!is.na(Catch)) %>%  # remove NAs earlier
  left_join(Index_Code,
            by ="INDEX") %>% 
  group_by(Species,Territory,Year) %>% 
  summarise(Total_Catch = sum(Catch,na.rm=T)) %>% 
  group_by(Species,Territory) %>% 
  summarise(Mean_Catch = mean(Total_Catch,na.rm=T))
)
return(Catch_Data)
  
}

```

#### Run Subroutine

```{r SAU_Catch_Data, eval = F, echo = F}

# get SAU catch data per species per nation

# Data needed for function
CoorG <- read.csv(paste(Data_Path,"Spatial_Data/coordinates_gab.csv",sep="")) %>%
  mutate(INDEX = seq(1,259200,1))

EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))
EEZ_CellID <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/EEZ_CellID.xlsx",sep=""))
colnames(EEZ_CellID) <- c("EEZID","INDEX")
  
  Index_Code <- EEZIDs_List %>% 
    left_join(EEZ_CellID) %>% 
    rename(Territory = Name)

  # Get list of species catch
Trans_Spp_List <- unique(Clean_Results_Trans$TaxonKey)

# Run routine and save it for latter
Sau_Catch_Data <- bind_rows(mclapply(Trans_Spp_List, getSAUCatch, Coord=CoorG))

write.csv(Sau_Catch_Data,
          paste(Data_Path,"Distribution_Data/Sau_Catch_Data.csv",sep=""),
          row.names = F)

```

# Results

## Function `GetTransResults`

```{r Fun_GetTransResults, eval = F}

GetTransResults=function(Spp){

  # Set the path for each file
  Distpath <- paste(Results_Path,Spp,sep="")
  
  # Loads all files in a df
  Load_Data <- bind_rows(lapply(Distpath, FUN=fread))
  
  return(Load_Data)

}

```


## Load Results data

```{r Load_Results_Data, eval = F}

# Set Jurisdiction to EEZ or RFMO
Jurisdiction <- "EEZ"

# Updates result's path for the jurisdiction
Results_Path <- paste(Results_Path,Jurisdiction,"/",sep="")
Results_Path <- "/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Old_Results/"

# Species list to get species names
Exploited_Species <- fread(paste(Data_Path,"Distribution_Data/exploited_species_list.csv",sep=""))
Spp_Clasification <- fread(paste(Data_Path,"Distribution_Data/SppTaxonName.csv",sep=""))


# Spatial Data needed to remove duplicates
sau_eez_fes <- fread(paste(Data_Path,"Spatial_Data/sau_eez_fes.csv",sep=""))

Clean_sau_eez_fes <- sau_eez_fes %>% 
  gather("Type","FishingRegion",2,4) %>% 
  left_join(sau_eez_fes,
            by = ("fishing_entity_id")
  ) %>% 
  group_by(FishingRegion,fishing_entity) %>% 
  summarise(n())

# UN Regions dataset
UN_Regions <- read.csv(paste(Data_Path,"Spatial_Data/UN_Regions.csv",sep=""), header = TRUE) %>% 
  group_by(Territory = Country.or.Area,
    georegion = Region.Name) %>% 
  summarise(n=n()) %>% #merge china's 3 rows
  select(-n) %>% 
  filter(Territory != "") %>%  # there are three rows with "developing" status as in, the code
  ungroup() %>% 
  mutate(
    Territory = gsub("\\s*\\([^\\)]+\\)","",Territory),
    Territory = gsub("United Kingdom of Great Britain and Northern Ireland","United Kingdom",Territory),
    Territory = gsub( "United States of America", "USA",Territory),
    Territory = gsub("Democratic People's Republic of Korea", "Korea (North)",Territory),
    Territory = gsub("Republic of Korea", "Korea (South)",Territory),
    Territory = gsub("Iran (Islamic Republic of)", "Iran",Territory),
    Territory = gsub("Democratic Republic of the Congo", "Congo (ex-Zaire)",Territory),
    # Territory = gsub("Congo", "Congo, R. of",Territory),
    Territory = gsub("United Republic of Tanzania", "Tanzania",Territory),
    Territory = gsub("Cabo Verde", "Cape Verde",Territory),
    Territory = gsub("Timor-Leste", "Timor Leste",Territory),
    Territory = gsub(" and ", " & ",Territory),
    # Territory = gsub("Puerto Rico (USA)", "Puerto Rico",Territory),
    Territory = gsub("Taiwan", "Taiwan (China)",Territory)
  )

# Manually change congo
UN_Regions[52,1] <- "Congo, R. of"

# Load Land shapefile
path_world_land <- paste(Data_Path,"Spatial_Data/ne_50m_admin_0_countries",sep="")
# #The File
fnam_world_land <- "ne_50m_admin_0_countries.shp"

World_land_sf <- st_read(dsn = path_world_land,
                         layer =file_path_sans_ext(fnam_world_land)) %>% 
  rename(Territory = NAME) 

# head(World_land_sf)
# Transboundary Results ####


# For Carmelia
if(Jurisdiction == "EEZ"){
  if(Sys.info()[7] == "carmelia"){
    Clean_Results_Trans <- read.csv(paste(Data_Path,"Clean_Results.csv",sep="")) # losad carmelia data
  }else{
    # Read Sau Catch Data
    Sau_Catch_Data <- fread(paste(Data_Path,"Distribution_Data/Sau_Catch_Data.csv", sep ="")) %>% 
      filter(!is.na(Territory))
    # For Hall and The Beast
    # List of species
    Spp <- list.files(Results_Path)[1:672]
    
    # Get resukts for all species
    Results_Trans <- GetTransResults(Spp)
    
    # Clean out countries that share with their own borders (Will be outdated soon)
    Auto_Remove_Territories <- Results_Trans %>%   
      rename(FishingRegion=Country_Territory) %>% 
      left_join(Clean_sau_eez_fes,
                by = "FishingRegion") %>% 
      select(TaxonKey,
             Country_Territory= FishingRegion,
             FishingRegion=Neighbor_Territory, #Neighbour_Territory
             Model_Index,
             Area_Index,
             CT_fishing_entity= fishing_entity) %>% 
      left_join(Clean_sau_eez_fes,
                by = "FishingRegion") %>% 
      select(1,2, 
             Neighbor_Territory = FishingRegion,
             Model_Index:CT_fishing_entity,
             NT_fishing_entity= fishing_entity,
             everything()) %>% 
      mutate(
        CT_fishing_entity = ifelse(is.na(CT_fishing_entity),paste(Country_Territory),paste(CT_fishing_entity)),
        NT_fishing_entity = ifelse(is.na(NT_fishing_entity),paste(Neighbor_Territory),paste(NT_fishing_entity)),
        Same_Nation = ifelse(CT_fishing_entity==NT_fishing_entity,"Yes","No")
      )
    
    #### Manual removal of those left... 
    
    # List of territories to eliminate (No other neighobors but mainland)
    Islands_to_Remove <- c(
      "Brazil (Fernando de Noronha)",
      "Brazil (St Paul and St. Peter Archipelago)",
      "Hawaii Main Islands (USA)",
      "Hawaii Northwest Islands (USA)",
      "Juan Fernandez Islands (Chile)",
      "Kermadec Isl. (New Zealand)"
    )
    
    # Complete list of territories to remove from dataset (Including islands)
    
    Territories_to_Remove <- Results_Trans %>% 
      filter(
        Country_Territory %in% Islands_to_Remove |
          Neighbor_Territory %in% Islands_to_Remove |
          Country_Territory == "Balearic Island (Spain)" & Neighbor_Territory == "Spain (Mediterranean and Gulf of Cadiz)" |
          Country_Territory == "British Virgin Isl. (UK)" & Neighbor_Territory == "Anguilla" |
          Neighbor_Territory == "British Virgin Isl. (UK)" & Country_Territory == "Anguilla" |
          Country_Territory == "Corsica (France)" & Neighbor_Territory == "France (Mediterranean)" |
          Neighbor_Territory == "Corsica (France)" & Country_Territory == "France (Mediterranean)" |
          Country_Territory == "Crete (Greece)" & Neighbor_Territory == "Grece" |
          Neighbor_Territory == "Crete (Greece)" & Country_Territory == "Grece" |
          Country_Territory == "Cyprus (North)" & Neighbor_Territory == "Cyprus (South)" |
          Neighbor_Territory == "Cyprus (North)" & Country_Territory == "Cyprus (South)" |
          Country_Territory == "Channel Isl. (UK)" & Neighbor_Territory == "United Kingdom" |
          Neighbor_Territory == "Channel Isl. (UK)" & Country_Territory == "United Kingdom" |
          Country_Territory == "Glorieuse Islands (France)" & Neighbor_Territory == "Mayotte (France)" |
          Neighbor_Territory == "Glorieuse Islands (France)" & Country_Territory == "Mayotte (France)" |
          Country_Territory == "Guam (USA)" & Neighbor_Territory == "Northern Marianas (USA)" |
          Neighbor_Territory == "Guam (USA)" & Country_Territory == "Northern Marianas (USA)" |
          Country_Territory == "Italy" & Neighbor_Territory == "Sardinia (Italy)" |
          Neighbor_Territory == "Italy" & Country_Territory == "Sardinia (Italy)" |
          Country_Territory == "Italy" & Neighbor_Territory == "Sicily (Italy)" |
          Neighbor_Territory == "Italy" & Country_Territory == "Sicily (Italy)" |
          Country_Territory == "Japan (Daito Islands)" & Neighbor_Territory == "Japan (main islands)"|
          Neighbor_Territory == "Japan (Daito Islands)" & Country_Territory == "Japan (main islands)"|
          Country_Territory == "Japan (Daito Islands)" & Neighbor_Territory == "Japan (Ogasawara Islands)"|
          Neighbor_Territory == "Japan (Daito Islands)" & Country_Territory == "Japan (Ogasawara Islands)"|
          Country_Territory == "Norway" & Neighbor_Territory == "Svalbard Isl. (Norway)" |
          Neighbor_Territory == "Norway" & Country_Territory == "Svalbard Isl. (Norway)" |
          Country_Territory == "Sicily (Italy)" & Neighbor_Territory == "Sardinia (Italy)" |
          Neighbor_Territory == "Sicily (Italy)" & Country_Territory == "Sardinia (Italy)" |
          Country_Territory == "South Africa (Atlantic Coast)" & Neighbor_Territory == "South Africa (Indian Ocean Coast)" |
          Neighbor_Territory == "South Africa (Atlantic Coast)" & Country_Territory == "South Africa (Indian Ocean Coast)" |
          Country_Territory == "USA (Alaska, Arctic)" & Neighbor_Territory == "USA (Alaska, Subarctic)" |
          Neighbor_Territory == "USA (Alaska, Arctic)" & Country_Territory == "USA (Alaska, Subarctic)"
      ) %>%
      group_by(Country_Territory,Neighbor_Territory) %>% 
      summarise(n())
    
    # Cleaned results 
    Clean_Results_Trans <- Auto_Remove_Territories %>% 
      anti_join(Territories_to_Remove,
                by = c("Country_Territory","Neighbor_Territory")
      ) %>% 
      filter(Same_Nation == "No") %>% 
      rename(Territory = Country_Territory,
             Neighbour = Neighbor_Territory)
    
    # SAU shapefile
    
    # The path
    path_world <- paste(Data_Path,"Spatial_Data/SAU_Shapefile/",sep="")
    # #The File
    fnam_world <- "SAUEEZ_July2015.shp"
    # #Load it!
    
    ### Sau Catch Data
    
    SAU_Catch_Data <- fread(paste(Data_Path,"Distribution_Data/Sau_Catch_Data.csv",sep = ""), header = TRUE)
    
  } # closes ifstatement for carmelia temporal files
}else{ # Closes EEZ ifelse
  
  # List of files without the non-trans data file
  Spp <- list.files(Results_Path)
  Spp <- Spp[Spp !="Non_Transboundary_Data.csv"]
  
  # Results loaing 
  Results_Trans <- GetTransResults(Spp)
  
  # Cleaning results (No cleaning needed for now)
  Clean_Results_Trans <- Results_Trans
  
  # Load results for non transboundary (discrete) stocks
  Results_Discrete <- fread(paste(Results_Path,"Non_Transboundary_Data.csv",sep="")) %>% 
    filter(!is.na(TaxonKey))
  
  # Shapefiles 
  path_world <- paste(Data_Path,"Spatial_Data/RFMO/SAU_RFMO/",sep="")
  # #The File
  fnam_world <- "SAU_RFMO_Sept_2015.shp"
  
}

#  GLobal data depending on jursidiction
# Load Regional shapefiles 
World_sf <- st_read(dsn = path_world,
                    layer =file_path_sans_ext(fnam_world)) %>% 
  rename(Territory = Name)

```

## Determine Tresholds

```{r Results_Tresholds, eval =F, echo = F}

#### Determine transboundary stocks and countries based on selected trsholds ####

#### Select Tresholds ###

# Area Index
Min_AI <- 0.25 # Min area index
Max_AI <- 1-Min_AI # Max Area Index

# Model Index
MI <- 100 # Model Index

####_____End Select Tresholds_______ ###


#### Determine transboundary and non-transboundary species and nations

Transboundary_Spp <- Clean_Results_Trans %>% 
  filter(
         Area_Index >= Min_AI,
         Area_Index <= Max_AI,
         Model_Index == MI#,
         # Same_Nation == "No"
         ) %>% 
  group_by(Territory) %>% 
  summarise(
    n_trans_spp = length(unique(TaxonKey)),
    n_Neighbours = length(unique(Neighbour)),
    Trans_Rate = n_trans_spp/n_Neighbours
    )
  
### Non-transboundary

Discrete_Spp <- Clean_Results_Trans %>% 
  filter(
         Area_Index < Min_AI |
         Area_Index > Max_AI,
         Model_Index == MI#,
         # Same_Nation == "No"
         ) %>% 
  group_by(Territory) %>% 
  summarise(
    n_no_discrete_spp = length(unique(TaxonKey)),
    n_Territories = length(unique(Territory))
    )



```

## Results per Territory

### Map of Transboundary Species

```{r Territory_Map, eval =F, echo =F}

World_sf_si <- World_sf %>%
  st_transform(crs = 4326) %>% # 4326
  # st_transform(crs = "+proj=moll") %>% # tubed world
  st_simplify(preserveTopology = TRUE, dTolerance = 0.1) %>%
  left_join(Transboundary_Spp, by ="Territory") 

Catch_Country <- Sau_Catch_Data %>% 
  group_by(FishingRegion=Territory) %>% 
  summarise(Total_Catch = round(sum(Mean_Catch,na.rm=T),2)) %>% 
  filter(!(is.na(FishingRegion))) %>% 
  left_join(Clean_sau_eez_fes) %>% 
  group_by(Territory = fishing_entity) %>% 
  summarise(Total_Catch = sum(Total_Catch,na.rm=T))

World_sf_si_land <- World_land_sf %>%
  st_transform(crs = 4326) %>% # 4326
  # st_transform(crs = "+proj=moll") %>% # tubed world
  st_simplify(preserveTopology = TRUE, dTolerance = 0.1) %>%  # Include transboundary species
  left_join(Catch_Country, by ="Territory") # Include total specices catch
  
# head(World_sf_si)s

# Create a pellet for plotting
# pal <- wes_palette("Zissou1", 1000, type = "continuous")

World_sf_si$Bins <- cut(World_sf_si$n_trans_spp,breaks = 5)
World_sf_si_land$BinsLan <- cut(World_sf_si_land$Total_Catch,breaks = 5)

unique(World_sf_si$Bins)
unique(World_sf_si_land$BinsLan)

levels(World_sf_si$Bins)
levels(World_sf_si_land$BinsLan)

Plot <- ggplot() +
  geom_sf(data = World_sf_si_land,aes(fill = BinsLan)) +
  geom_sf(data = World_sf_si,aes(fill = Bins)) + # n_trans_spp or Bins
  # scale_fill_gradientn(colours = pal,
  #                      na.value = "white") +
  # scale_fill_manual(values = c(rev(wes_palette(n = 4, name = "Darjeeling1")),
  #                              rev(wes_palette(n = 4, name = "Darjeeling1"))
  #                              ),
  #                    na.value = "white"
  # ) +
  scale_fill_manual("",values = c("#5BBCD6","#5BBCD6","#F98400","#F98400","#F2AD00","#F2AD00","#00A08A","#FF0000","#FF0000","#FF0000"),
                     na.value = "white"
  ) +
  # scale_fill_manual(values = rev(wes_palette(n = 5, name = "Darjeeling1")),
  #                    na.value = "white"
  # ) +
  ggtheme_map()

Plot_Name <- paste(Jurisdiction,"_100_25_Bins_Land.png", sep = "") 

ggsave(Plot_Name,
       plot = Plot,
       width = 16,
       height = 8,
       units = "in",
       path = "/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Figures/"
)


```

### OHI-inspired Circular plot for Territories

```{r Territories_Circluar_Plot, eval = T, echo = T}

Countries_Data <- Clean_Results_Trans %>% 
  filter(
         Area_Index >= Min_AI,
         Area_Index <= Max_AI,
         Model_Index == MI,
         Same_Nation == "No"
         ) %>% 
  group_by(Territory = CT_fishing_entity) %>% 
  summarise(value = length(unique(TaxonKey))) %>% 
  left_join(UN_Regions, by ="Territory") %>%
  mutate(group = ifelse(is.na(georegion),"Other",paste(georegion))) %>% 
  rename(FishingRegion=Territory) %>% 
  left_join(Clean_sau_eez_fes) %>% 
  group_by(individual = fishing_entity,group) %>% 
  summarise(Total_trans = sum(value,na.rm=T)) %>% 
  filter(!is.na(individual)) %>% 
  select(individual,group,value=Total_trans) %>% 
  arrange(group,value)


# hist(Countries_Data$value)
# unique(Countries_Data$group)
Median_trans <- median(Countries_Data$value,na.rm=T)
Char <- as.factor(Countries_Data$group)

# Set a number of 'empty bar' to add at the end of each group
empty_bar <- length(unique(Countries_Data$group))
to_add <- data.frame( matrix(NA, empty_bar*nlevels(Char), ncol(Countries_Data)) )
colnames(to_add) <- colnames(Countries_Data)
to_add$group <- rep(levels(Char), each=empty_bar)
Countries_Data <- bind_rows(Countries_Data, to_add)
Countries_Data <- Countries_Data %>% arrange(group,value)
Countries_Data$id <- seq(1, nrow(Countries_Data))
 
# Get the name and the y position of each label

# Top n of each group label
Top_Countries <- Countries_Data %>% 
  group_by(group) %>% 
  top_n(5,value)

# Create labels for all but top 5
label_data <- Countries_Data 
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)

# Remove top 5
label_data_rest <- label_data %>% 
  filter(!individual %in% Top_Countries$individual)

# Create labels for top 5
Top_label_data <- label_data %>% 
  filter(individual %in% Top_Countries$individual)

# prepare a data frame for base lines
base_data <- Countries_Data %>% 
  group_by(group) %>% 
  summarize(start=min(id), 
            end=max(id) - empty_bar, 
            median = median(value, na.rm = T)
            ) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)))

# prepare a data frame for grid (scales)
grid_data <- base_data
grid_data$end <- grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1
grid_data$start <- grid_data$start - 1
grid_data[1,2] <- 5 # Manually include Africa for the median
grid_data[1,3] <- 1

# Median data
median_data <- grid_data %>% 
  mutate_at(vars(start,end),
            .funs = as.numeric)
 
# -------------------------- #
# Make the plot
# -------------------------- #
# Base plot
ggplot(Countries_Data, 
       aes(x=as.factor(id), 
           y=value,
           fill=group)
       ) +       # Note that id is a factor. If x is numeric, there is some space between the first bar
  geom_bar(aes(x=as.factor(id),
               y=value,
               fill=group),
           stat="identity",
           alpha=0.5) +
  # Add a val=100/75/50/25 lines. I do it at the beginning to make sur barplots are OVER it.
  geom_segment(data=grid_data, aes(x = end, y = 100, xend = start, yend = 100), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 80, xend = start, yend = 80), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 60, xend = start, yend = 60), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 40, xend = start, yend = 40), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 20, xend = start, yend = 20), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  # Add median lines for each gropup
  geom_segment(data=median_data, aes(x = end, y = median, xend = start+5, yend = median, colour = group),
               alpha=1, size=0.5 , inherit.aes = FALSE ) +
  # geom_hline(yintercept = Median_trans, colour = "black", alpha=1, size=0.3,linetype="dashed") + # All groups median
  # Add text showing the value of each line
  annotate("text", 
           x = rep(max(Countries_Data$id),5),
           y = c(20, 40, 60, 80, 100),
           label = c("20", "40", "60","80",">100"),
           color="grey", 
           size=3 , 
           angle=0, 
           fontface="bold",
           hjust=1) +
  geom_bar(aes(x=as.factor(id),
               y=value,
               fill=group),
           stat="identity",
           alpha=0.5) +
  geom_text(data=label_data_rest,
            aes(x=id, y=110,
                label=individual,
                hjust=hjust), 
            color="black",
            # fontface="bold",
            alpha=0.6,
            size=2.5,
            angle= label_data_rest$angle,
            inherit.aes = FALSE) +
  # Bold top 3 
  geom_text(data=Top_label_data,
            aes(x=id, y=110,
                label=individual,
                hjust=hjust), 
            color="black",
            fontface="bold",
            alpha=0.6,
            size=2.5,
            angle= Top_label_data$angle,
            inherit.aes = FALSE) +
  # Add base line information
  geom_segment(data=base_data, 
               aes(x = start, 
                   y = -5, 
                   xend = end, 
                   yend = -5
                   ), 
               colour = "black",
               alpha=0.8, 
               size=0.6 , 
               inherit.aes = FALSE) +
  ylim(-140,140) + # sets the circle the first value the central the last value how wide
  theme_minimal() +
  theme(
    legend.position = c(0.5,0.5),
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-1,4), "cm") 
  ) +
  coord_polar() + 
  scale_fill_manual("Continent",
                    values = c(wes_palette(n = 5, name = "Darjeeling1"),
                               wes_palette(n = 4, name = "Darjeeling2")
                    ),
                    na.value = "white"
  ) +
  scale_colour_manual("Continent",
                      values = c(wes_palette(n = 5, name = "Darjeeling1"),
                                 wes_palette(n = 4, name = "Darjeeling2")
                      ),
                      na.value = "white"
  )

#  Warring of missing values are the NA's for the columns

# Save plot

# ggsave(
#     plot = last_plot(),
#     width = 14,
#     height = 10,
#     units = "in",
#     filename = "Territory_circular.tiff",
#     path = "/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Figures/"
#   )
 

```

```{r Top_country_Circle_Diagram, eval =F, echo = F}

# Top 10 species

# Number of countries shared by each Species
Top_10_Countries <- Clean_Results_Trans %>% 
  filter(
         Area_Index < Min_AI |
         Area_Index > Max_AI,
         Model_Index == MI,
         Same_Nation == "No"
         ) %>% 
  group_by(Country_Territory) %>% 
  summarise(
    n_countries = length(unique(TaxonKey))
  ) %>% 
  top_n(10,n_countries)

# Countries that share the top 10
Top_Ten_Countries <- Clean_Results_Trans %>% 
  filter(
         Area_Index < Min_AI |
         Area_Index > Max_AI,
         Model_Index == MI,
         Same_Nation == "No",
         Country_Territory %in% Top_10_Countries$Country_Territory
         ) %>% 
  group_by(from=CT_fishing_entity,
           to=NT_fishing_entity
           ) %>% 
  summarise(value=n()
            ) %>% 
  ungroup() %>% 
  mutate(from = paste("F", from),
         to = paste("T", to)
         )

####________________###
# Circulize package ####
# https://jokergoo.github.io/circlize_book/book/
####________________###
  

# To set links collor 
Bins <- as.numeric(cut(Top_Ten_Countries$value,breaks = 5))

# Basic plot
circos.clear()
chordDiagram(Top_Ten_Countries, 
             annotationTrack = c("grid", "axis"), # keep grid and axis but not labels
             annotationTrackHeight = c(0.001, 0.05), # set links close to the axis
             directional = 1, # direction of arrows
             direction.type = c("diffHeight", "arrows"), # use arrows
             grid.col = "white",
             col = ifelse(Bins == 1,"#046C9A", # deep blue
                          ifelse(Bins == 2,"#78B7C5", #light blue
                                 ifelse(Bins == 3,"#EBCC2A", #yellow
                                        ifelse(Bins == 4, "#E1AF00", #cream
                                               "#F21A00")))), #red
             link.arr.col = wes_palette("Zissou1"),
             link.arr.type = "big.arrow",# make links big arrows
             diffHeight = uh(1, "mm"), # brings the arrow to the bottom of the source
             # annotationTrack = "grid", # no labels
             scale = FALSE, # fraction of total instead of absolute value
             preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(Top_Ten_Countries))))) # I have no idea but helps with the labels
    ) 
#  Rest of eddits
circos.track(track.index = 1, panel.fun = function(x, y) {
    xlim = get.cell.meta.data("xlim")
    xplot = get.cell.meta.data("xplot")
    ylim = get.cell.meta.data("ylim")
    sector.name = get.cell.meta.data("sector.index")
    
    circos.text(mean(xlim),
                ylim[1], 
                sector.name, 
                facing = "clockwise",
                niceFacing = TRUE,
                adj = c(-0.2, 0.5),
                col = "black")
    
}, bg.border = NA)



```

## Analysis per Species

```{Tran_country, eval =F, echo =F}

# Number of Transboundary Species
length(unique(Clean_Results_Trans$TaxonKey)) #664 spp


# Number of Discret EEZ species

# Ge those stocks that are not trans due to Area_Index
length(unique(Results_Discrete$TaxonKey))


```

```{r n_species_country, eval = T, echo =F}
# Number of countries shared by each Species
Species_Trans <- Clean_Results_Trans %>% 
  filter(
         Area_Index < Min_AI |
         Area_Index > Max_AI,
         Model_Index == MI,
         Same_Nation == "No"
         ) %>% 
  group_by(TaxonKey) %>% 
  summarise(
    n_countries = length(unique(Territory))
  ) %>% 
  left_join(Exploited_Species) %>%
  left_join(Spp_Clasification)

# hist(Species_Trans$n_countries)

# Use rfishbase to get species environment

Species_list <- Species_Trans %>% 
  mutate(scientific_name = paste(Genus,Species)) %>% 
  pull(scientific_name)

Species_environ_list <- rbind(species(Species_list, 
                                      fields = species_fields$habitat[4])
) %>% 
  mutate(scientific_name = Species_list)

```

```{habitat_barplot, eval =F, echo =F}

Species_data <- Species_Trans %>% 
  mutate(scientific_name = paste(Genus,Species)) %>%
  left_join(Species_environ_list) %>% 
  mutate(DemersPelag = replace_na(DemersPelag, "Other")) %>% 
  mutate(Distance = ifelse(DemersPelag == "reef-associated", 1,
                           ifelse(DemersPelag =="pelagic-neritic",2,
                                  ifelse(DemersPelag == "demersal",3,
                                         ifelse(DemersPelag == "pelagic-oceanic",4,
                                                ifelse(DemersPelag =="benthopelagic",5,
                                                       ifelse(DemersPelag =="bathypelagic",6,
                                                              ifelse(DemersPelag =="bathydemersal",7,
                                                                     8)))))))
  ) %>% 
  group_by(DemersPelag,Distance) %>% 
  summarise(Countries_Genus = sum(n_countries,na.rm=T),
            Mean_Countries_Genus = mean(n_countries,na.rm=T),
            sd_Countries_Genus = sd(n_countries,na.rm=T),
            N_spp =length(unique(TaxonName))
  )

ggplot(Species_data,
       aes(
         x = reorder(DemersPelag,desc(Distance)),
         y = Mean_Countries_Genus,
         fill = Countries_Genus#,
         # colour = Countries_Genus
       )
) +
  geom_bar(stat = "identity") +
  # geom_errorbar(data = Species_data,
  #               aes(
  #                 x = reorder(DemersPelag,desc(Distance)),
  #                 ymin=Mean_Countries_Genus-sd_Countries_Genus, # mean +- 2*sd
  #                 ymax=Mean_Countries_Genus+sd_Countries_Genus
  #               ),
  #               colour = "black",
  #               width=.2,
  #               linetype = 2,
  #               size = 0.6,
  #               alpha = 0.5
  # ) +
  geom_text(data = Species_data, 
            aes(
              x = reorder(DemersPelag,desc(Distance)),
              y = 2,
              label = paste(as.character(N_spp), "species"),
            ),
            colour = "black"
  ) +
  coord_flip() +
  scale_fill_gradientn("Total number\nof countries",
                       colours = wes_palette("Zissou1"),
                       limits = c(0,1500),
                       breaks = seq(0,1500,250)
  ) +
  scale_colour_gradientn("Total number\nof countries",
                         colours = wes_palette("Zissou1"),
                         limits = c(0,1500),
                         breaks = seq(0,1500,250)
  ) +
  scale_y_continuous(breaks=seq(0, 40, 5), 
                     limits=c(0, 40)
                     )+
  labs(
    x = "Habitat type",
    y = "Mean number of countries per habitat"
  ) +
  ggtheme_plot()

```

### OHI-inspired Circular plot Species

```{r species_circluar_plot, eval = T, echo = T}

Species_Data <- Clean_Results_Trans %>% 
  filter(
         Area_Index >= Min_AI,
         Area_Index <= Max_AI,
         Model_Index == MI#,
         # Same_Nation == "No"
         ) %>% 
  group_by(TaxonKey) %>% 
  summarise(n_trans_spp = length(unique(Territory))) %>% 
  left_join(Exploited_Species) %>%
  rename(scientific_name = TaxonName) %>% 
  left_join(Species_environ_list) %>%
  mutate(DemersPelag = ifelse(is.na(DemersPelag),"Other",paste(DemersPelag)),
         n_trans_spp = ifelse(n_trans_spp > 100, 100, n_trans_spp)) %>% 
  select(individual=scientific_name,
         value = n_trans_spp,
         group = DemersPelag) %>% 
  arrange(group,value) %>% 
  filter(value > 10) # remove all species under 10 (way too many to plot!)

Median_trans <- median(Species_Data$value)
# hist(Species_Data$value)
# unique(Species_Data$group)

Char <- as.factor(Species_Data$group)

# Set a number of 'empty bar' to add at the end of each group
empty_bar <- 8
to_add <- data.frame( matrix(NA, empty_bar*nlevels(Char), ncol(Species_Data)) )
colnames(to_add) <- colnames(Species_Data)
to_add$group <- rep(levels(Char), each=empty_bar)
Species_Data <- rbind(Species_Data, to_add)
Species_Data <- Species_Data %>% arrange(group,value)
Species_Data$id <- seq(1, nrow(Species_Data))

# Get the name and the y position of each label



# Create labels for all but top 5
label_data <- Countries_Data 
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)


# Get the name and the y position of each label
# Top n of each group label
Top_spp <- Species_Data %>% 
  group_by(group) %>% 
  top_n(5,value)

# Create labels for all but top 5
label_data <- Species_Data
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     # I substract 0.5 because the letter must have the angle of the center of the bars. Not extreme right(1) or extreme left (0)
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)

# Remove top 5
label_data_rest <- label_data %>% 
  filter(!individual %in% Top_spp$individual)

# Create labels for top 5
Top_label_data <- label_data %>% 
  filter(individual %in% Top_spp$individual)


# prepare a data frame for base lines
base_data <- Species_Data %>% 
  group_by(group) %>% 
  summarize(start=min(id), 
            end=max(id) - empty_bar, 
            median = median(value, na.rm = T)
            ) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)))


# prepare a data frame for grid (scales)
grid_data <- base_data
grid_data$end <- grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1
grid_data$start <- grid_data$start - 1
# grid_data <- grid_data[-1,]
grid_data[1,2] <- 5 # Manually include bathydemerssal
grid_data[1,3] <- 1 

# Median data
median_data <- grid_data %>% 
  mutate_at(vars(start,end),
            .funs = as.numeric)

# Make the plot
ggplot(Species_Data, 
       aes(x=as.factor(id), 
           y=value,
           fill=group)
       ) +       # Note that id is a factor. If x is numeric, there is some space between the first bar
  geom_bar(aes(x=as.factor(id),
               y=value,
               fill=group),
           stat="identity",
           alpha=0.5) +
  # Add a val=100/75/50/25 lines. I do it at the beginning to make sur barplots are OVER it.
  geom_segment(data=grid_data, aes(x = end, y = 100, xend = start, yend = 100), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 80, xend = start, yend = 80), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 60, xend = start, yend = 60), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 40, xend = start, yend = 40), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = end, y = 20, xend = start, yend = 20), colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  # Add median lines for each gropup
  geom_segment(data=median_data, aes(x = end, y = median, xend = start+5, yend = median, colour = group),
               alpha=1, size=0.5 , inherit.aes = FALSE ) +
  # geom_hline(yintercept = Median_trans, colour = "black", alpha=1, size=0.3,linetype="dashed") + # All groups median
  # Add text showing the value of each line
  annotate("text", 
           x = rep(max(Species_Data$id),5),
           y = c(20, 40, 60, 80, 100),
           label = c("20", "40", "60","80",">100"),
           color="grey", 
           size=3 , 
           angle=0, 
           fontface="bold",
           hjust=1) +
  geom_bar(aes(x=as.factor(id),
               y=value,
               fill=group),
           stat="identity",
           alpha=0.5) +
  geom_text(data=label_data_rest,
            aes(x=id, y=110,
                label=individual,
                hjust=hjust), 
            color="black",
            # fontface="bold",
            alpha=0.6,
            size=2.5,
            angle= label_data_rest$angle,
            inherit.aes = FALSE) +
  # Bold top 3 
  geom_text(data=Top_label_data,
            aes(x=id, y=110,
                label=individual,
                hjust=hjust), 
            color="black",
            fontface="bold",
            alpha=0.6,
            size=2.5,
            angle= Top_label_data$angle,
            inherit.aes = FALSE) +
  # Add base line information
  geom_segment(data=base_data, 
               aes(x = start, 
                   y = -5, 
                   xend = end, 
                   yend = -5
                   ), 
               colour = "black",
               alpha=0.8, 
               size=0.6 , 
               inherit.aes = FALSE) +
  ylim(-140,140) + # sets the circle the first value the central the last value how wide
  theme_minimal() +
  theme(
    legend.position = c(0.5,0.5),
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-1,4), "cm") 
  ) +
  coord_polar() + 
  scale_fill_manual("Ecosystem Preference",
                    values = c(wes_palette(n = 5, name = "Darjeeling1"),
                               wes_palette(n = 4, name = "Darjeeling2")
                    ),
                    na.value = "white"
  ) +
  scale_colour_manual("Ecosystem Preference",
                      values = c(wes_palette(n = 5, name = "Darjeeling1"),
                                 wes_palette(n = 4, name = "Darjeeling2")
                      ),
                      na.value = "white"
  )

ggsave(
    plot = last_plot(),
    width = 14,
    height = 10,
    units = "in",
    filename = "Species_circular_over10.tiff",
    path = "/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Figures/"
  )
 
```

```{r Top_spp_Circle_Diagram, eval =F, echo = F}

# Top 5 shared species per marine environment (number of countries sharing the species)
Top_Species <- Species_Trans %>% 
  mutate(scientific_name = paste(Genus,Species)) %>%
  left_join(Species_environ_list) %>% 
  mutate(DemersPelag = replace_na(DemersPelag, "Other")) %>% 
  # group_by(TaxonKey,TaxonName,CommonName,DemersPelag) %>% 
  # summarise(Sum_Countries =sum(n_countries,na.rm=T)) %>% 
  group_by(DemersPelag) %>% 
  top_n(5,n_countries)

# Countries that share the top 10
Top_Spp_Countries <- Clean_Results_Trans %>% 
  filter(
    Area_Index < Min_AI |
      Area_Index > Max_AI,
    Model_Index == MI,
    Same_Nation == "No",
    TaxonKey %in% Top_Species$TaxonKey
  ) %>% 
  left_join(Species_Trans) %>% 
  rename(scientific_name =TaxonName) %>%
  left_join(Species_environ_list) %>% 
  mutate(from = paste(Genus,"\n",Species,sep=""),
         DemersPelag = replace_na(DemersPelag, "Other")) %>%
  group_by(
    # from,
    from = scientific_name,
           to=CT_fishing_entity,
           DemersPelag
  ) %>% 
  summarise(value=n()
  ) #%>%
  # filter(DemersPelag == "demersal") %>%
  # select(-DemersPelag)


####________________###
# Circulize package ####
# https://jokergoo.github.io/circlize_book/book/
####________________###
  
# To set links color 
Bins <- as.numeric(cut(Top_Spp_Countries$value,breaks = 5)) # By size of sharing

# To get country's flags... https://flagpedia.net/download
flags <- c(paste("Temporal_Data/flags-mini/",list.files("Temporal_Data/flags-mini/"),sep=""))

# List of Ecosystems
Classification <- Top_Species %>% group_by(DemersPelag) %>% summarise(n()) %>%  pull(DemersPelag)

####________________ PLOT PER ECOSYSTEM _____________________ ###

for(s in 1:2){ # sclae loop
  for(i in 1:length(Classification)) {
    # for(i in 1:2) { # for testing
    
    # Set scales to plott both absolut and proportional values
    if(s == 1){
      Scales <- "TRUE"
    }else{
      Scales <- "FALSE"
    }
    
    # Saving the plot
    Plot_name <- paste(Figures_Path,Classification[i],Scales,".tiff",sep="")
    tiff(Plot_name, width = 5, height = 5, units = 'in', res = 500)
    
    # Subsetting the data for each plot
    DemersPelag_i <- Classification[i]
    
    Data <- Top_Ten_Spp_Countries %>% 
      filter(DemersPelag %in% DemersPelag_i) %>% 
      select(-3)
    
    # Use to set links' colors to each species
    Speceis_cols <- Data %>% group_by(from) %>% summarise(n()) %>% pull(from)
    
    # The base plot
    circos.clear()
    chordDiagram(Data, 
                 annotationTrack = c("grid", "axis"), # keep grid and axis but not labels
                 annotationTrackHeight = c(0.001, 0.1), # set links close to the axis
                 directional = 1, # direction of arrows
                 direction.type = c("diffHeight", "arrows"), # use arrows
                 grid.col = "grey",
                 # if col == Bins then colors will change depending of value
                 # col = ifelse(Bins == 1,"#046C9A", # deep blue
                 #              ifelse(Bins == 2,"#78B7C5", #light blue
                 #                     ifelse(Bins == 3,"#EBCC2A", #yellow
                 #                            ifelse(Bins == 4, "#E1AF00", #cream
                 #                                   "#F21A00")))), #red
                 # if col == Species_cols then colors will change depending of species
                 col = ifelse(Data$from == Speceis_cols[1],"#FF0000", # deep blue
                              ifelse(Data$from == Speceis_cols[2],"#00A08A", #light blue
                                     ifelse(Data$from == Speceis_cols[3],"#F2AD00", #yellow
                                            ifelse(Data$from == Speceis_cols[4], "#F98400", #cream
                                                   "#5BBCD6")))), #red
                 # link.arr.col = wes_palette("Zissou1"), 
                 link.arr.type = "big.arrow",# make links big arrows
                 diffHeight = uh(-0.5, "mm"), # brings the arrow to the bottom of the source
                 scale = Scales, # fraction of each species to total share of each country instead of absolute value
                 preAllocateTracks = list(track.height = max(strwidth(unlist(dimnames(Data))))) # I have no idea but helps with the labels
    )
    
    #  Function to inlcude other layers
    circos.track(track.index = 1, panel.fun = function(x, y) {
      xlim = get.cell.meta.data("xlim")
      xplot = get.cell.meta.data("xplot")
      ylim = get.cell.meta.data("ylim")
      sector.name = get.cell.meta.data("sector.index")
      
      # Add labels
      circos.text(mean(xlim),
                  ylim[1],
                  sector.name,
                  facing = "clockwise",
                  niceFacing = TRUE,
                  adj = c(-0.2, 0.5),
                  col = "black",
                  cex = 0.6) # size of labels
      
      # Add country's flags instead of names (still need to link names to falgs)
      
      # library(EBImage)
      # pos = circlize:::polar2Cartesian(circlize(CELL_META$xcenter, CELL_META$ycenter))
      # image = EBImage::readImage(flags[CELL_META$sector.numeric.index])
      # 
      # rasterImage(image,
      #             xleft = pos[1, 1] - 0.006, 
      #             ybottom = pos[1, 2] - 0.005,
      #             xright = pos[1, 1] + 0.05,
      #             ytop = pos[1, 2]+ 0.04
      #             )
      
      # END FLAGS TRYOUT
      
      # Set plot Title
      Title <- paste("Top",Classification[i], "Species",sep =" ")
      title(Title)
      
    }, bg.border = NA) #end of circos.track
    
    dev.off()
  } # close for loop
} #close scale loop

```

# Problem solving



### First world Anchovies

In a first run the model suggests anchovies "Engraulis ringens" (600004) is transboundary between US-Mex-Can. I'm exploring this since all four models agree...

Found the probelm, Gab's coordinate system, hecne the data, are in different system than DBEM and SAU data...


```{r Trans_Spp_Function, eval= F ,echo = T,warning = F,message = F}

### DATA EXTRA NEEDED 

# DBEM Coordinate system
Coor <- fread(paste(Data_Path,"Spatial_Data/Lon_Lat_DBEM.txt",sep=""),header = FALSE)
colnames(Coor) <- c("INDEX","Longitude","Latitude")
EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))
EEZ_CellID <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/EEZ_CellID.xlsx",sep=""))
colnames(EEZ_CellID) <- c("EEZID","INDEX")

CoorG <- read.csv(paste(Data_Path,"Spatial_Data/coordinates_gab.csv",sep="")) %>% 
  mutate(INDEX = seq(1,259200,1))

# colnames(CoorG) <- c("INDEX","Longitude","Latitude")
coords <- CoorG[order(CoorG$Latitude, rev(CoorG$Longitude),decreasing=TRUE), ] 

# Explore model step by step

# Get Catch Data
Anchoveta_Dist <- GetSppDist(600004,"All",CoorG)


Anchoveta_Dist_Coor <- Anchoveta_Dist %>% 
  left_join(CoorG)

# Swap coordinate system to match DBEM and SAU
Anchoveta_Dist_Coor_Fix <- Anchoveta_Dist_Coor[order(Anchoveta_Dist_Coor$Latitude, rev(Anchoveta_Dist_Coor$Longitude),decreasing=TRUE), ] 


x <- Anchoveta_Dist %>% 
  left_join(EEZ_CellID) %>% 
  left_join(EEZIDs_List) %>% 
  filter(
    # Model == "Occ",
    Value >0)


# head(x)
# Exploring using Vicky's data

ggplot(x) +
  geom_tile(aes(
    x = Longitude,
    y = Latitude,
    fill = Name,
    color = Name
  )
  ) +
  facet_wrap(~Model)


Spp_Trans <- bind_rows(
    mclapply(
      600004, FUN =EstTransIndex, Model = "All", Neighbours = Neighbour_List, Coord = CoorG
    )
  )


  # Estimate total spp distribution within neighbours
  
  Trans_Spp <- SppDist %>%
    filter(INDEX %in% Neighbours$INDEX) %>% # Filter data only located within EEZs
    mutate(Value = ifelse(Value > 0, 1,0)) %>%  # For now using SAU_C as presence absence
    group_by(TaxonKey,
             INDEX
    ) %>%
    summarise(Model_Index = mean(Value,na.rm=T)) %>%
    filter(Model_Index > 0) %>%
    mutate(Model_Index = Model_Index*100) %>%
    left_join(Neighbours,
              by = "INDEX")
    
    Test <- Trans_Spp %>% 
      filter(Name == "USA (West Coast)" & Model_Index ==100)


 # Explore only SAU catch data

# Get Catch Data
Anchoveta_Dist <- GetSppDist(Spp,"SAU_C")
    
# Get Mex, Can and USA W coast Grid
Anchoveta_Dist_EEZ <- Anchoveta_Dist %>% 
  

Anchoveta_NA <-  Anchoveta_Dist%>% 
  filter(INDEX %in% North_America$INDEX) %>% 
  gather("Year","Tonnes",CATCH.1:CATCH.65) %>% 
  group_by(Year) %>% 
  summarise(Sum_T = sum(Tonnes, na.rm =T))



```


#### Overcounting transboundary stocks

In a first run, Australia results in many transboundary stocks, I believe this is because it is counting the number of countries that that the species share (e.g. one species 6 countries = 6 transboundary spp) rather than 1 speces 6 countries = 1 trans spp.

**Problem fixed.** Now we can estimate the number of transboundary species as well as the number of countries/regions that each country shares per species.

```{Australia_case, eval =F, echo = F}

Australia <- Results_Data %>% 
  filter(Name == "Australia")

Original_Australia <-Australia %>% 
  filter(Model_Index >= 50#,
         # Trans_Index >= 0.10
         ) %>% 
  group_by(Name,Model_Index) %>% 
  summarise(n_Trans_Spp = n()) %>% 
  filter(Model_Index == 100)

## Testing the waters

Explore_Australia <- Australia %>% 
  filter(Model_Index >= 50#,
         # Trans_Index >= 0.10
         ) %>% 
  slice(1:20) %>% 
  group_by(Name,Model_Index) %>% 
  summarise(
    n_trans = length(unique(TaxonKey)),
    n_countries = length(unique(Neighbour_Territory)),
    )

```

#### Fixing counts within EEZs

In the first run. Countries where EEZs are devided but touching (e.g. South Africa inidan and atlantic coasts) are double counted.

This might be fixed with Tayler's data of EEZs to ISOs... He did it manually so it does not work! 

```{South_Africa_case, eval =F, echo = F}

# Tyler E.'s' data
EEZ_ISO <- read.csv("/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Spatial_Data/EEZID_ISO_TylEd.csv", comment.char="#")

#SAU / Vicky's data
EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))

EEZ_CellID <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/EEZ_CellID.xlsx",sep=""))
colnames(EEZ_CellID) <- c("EEZID","INDEX")

# Worlds adata

# The path
path_world <- paste(Data_Path,"Spatial_Data/World_EEZ_v10_2018",sep="")
# #The File
fnam_world <- "eez_v10.shp"
# #Load it!
# 
World_EEZs <- st_read(dsn = path_world,
                      layer =file_path_sans_ext(fnam_world))

head(World_EEZs)

World_EEZs %>% 
  filter(
    # Territory1 == "South Africa",
    ISO_Ter1 == "ZAF") %>% 
  head()

# Get ISO and territory names from world map
ISO_Ter <- World_EEZs %>%
  select(ISO_Ter1,Territory1) %>% 
  as.data.frame() %>% 
  select(ISO_Ter1,Territory1)

head(ISO_Ter)

# I think EEZID equals ISO when not devided... 

EZZID_Yes_ISO <- ISO_Ter %>% 
  semi_join(ISO_Ter,
            by ="ISO_Ter1") %>% 
  rename(Name = Territory1) %>% 
  # head() %>% 
  left_join(EEZIDs_List,
            by = "Name")


EEZ_ISO_Clean <- ISO_Ter %>% 
  left_join(EEZ_ISO,
            by = "ISO_Ter1")

SA <- Results_Data %>% 
  filter(stringr::str_detect(Name,"South Africa"))


## Creating a subset dataset so i can work on my laptop and not remoteley

SubsetData <- Clean_Results %>% 
  filter(Country_Territory=="USA (East Coast)")

write.csv(SubsetData,
          "SubsetData.csv",
          row.names = F) # Using USA East coast and Gulf as example

###_____________________________ ###

# Loading subsetted data

Clean_Results <- read.csv("~/GitHub/FishForVisa/Temporal_Data/SubsetData.csv")

sau_eez_fes <- read.csv("~/GitHub/FishForVisa/Temporal_Data/sau_eez_fes.csv")
  

Neighbourd_Territory_T <- Clean_Results %>% 
  group_by(eez_name=Neighbour_Territory) %>% 
  summarise() %>%
  left_join(sau_eez_fes,
            by = "eez_name") %>% 
  select(Neighbour_Territory= eez_name,
         NT_fishing_entity=fishing_entity
         )

Country_Territory_T <- Clean_Results %>% 
  group_by(eez_name=Country_Territory) %>% 
  summarise() %>%
  left_join(sau_eez_fes,
            by = "eez_name")  %>% 
  select(Country_Territory= eez_name,
         CT_fishing_entity=fishing_entity)

Non_duplicate_Data <- Clean_Results %>%   
  left_join(Neighbourd_Territory_T,
              by ="Neighbour_Territory") %>% 
  left_join(Country_Territory_T,
              by ="Country_Territory") %>% 
  mutate(
    Same_Nation = ifelse(CT_fishing_entity==NT_fishing_entity,"Yes","No")
  ) %>% 
  filter(Same_Nation == "No")


# FIXED!!!!! 

```

- **Done debugging**

#### Missing stocks

There are places like Peru-Chile or Alaska-Canada that should have trans spp... In Alaska the issue is that Alaska doesn't actually exist as a separate shapefile...

```{r Missing_stocks, eval =F}

Exploited_Species <- fread(paste(Data_Path,"Distribution_Data/exploited_species_list.csv",sep=""))

Clean_sau_eez_fes <- sau_eez_fes %>% 
  gather("Type","FishingRegion",2,4) %>% 
  left_join(sau_eez_fes,
            by = ("fishing_entity_id")
            ) %>% 
  group_by(FishingRegion,fishing_entity) %>% 
  summarise(n())


# The Alaska paradox
# It's a problem of the NAs, fixed.

USA_West <- Results_Data %>% 
  filter(Country_Territory == "USA (West Coast)") %>% 
  left_join(Exploited_Species,
            by = "TaxonKey")

# Northern sea Russia
Russia_map <- World_EEZs %>% 
  filter(stringr::str_detect(Name,"Russia")) %>% 
  st_simplify(preserveTopology = TRUE, dTolerance = 100) 

head(Russia_map)

ggplot(Russia_map) +
  geom_sf(aes(fill = Name)) 
# Shapefiles not matching
# Russia (Laptev to Chukchi Sea)
# Russia (Kara Sea)

Russian_Regions <- c("Russia (Laptev to Chukchi Sea)","Russia (Kara Sea)")

Russia_Results <- Results_Data %>% 
  filter(stringr::str_detect(Country_Territory,"Russia"))
  
unique(Russia_Results$Country_Territory)
# Missing Laptev to Chukchi sea

### What about Vicky's data
#SAU / Vicky's data
EEZIDs_List <- read_excel(paste(Data_Path,"Spatial_Data/V_Lam/Updated_EEZList_17June2016.xlsx",sep=""))

Russia_EEZlist <- EEZIDs_List %>% 
  filter(stringr::str_detect(Name,"Russia"))
  
unique(Russia_EEZlist$Name)

### So maybe there are no Neighbours?
Neighbour_List <- fread(paste(Data_Path,"Spatial_Data/Neighbour_List.csv", sep =""))

Russia_Neighbour <- Neighbour_List %>% 
  filter(stringr::str_detect(Name,"Russia"))
  
unique(Russia_Neighbour$Country_Territory)

# OK So Kara Sea has no borders outside Russia, hence white. Now Laptev does have borders but No species... which is weird... Paific Halibut?

# I manually ran the function to see what's going on

# ggplot() +
#   geom_sf(data = Russia_map, aes(colour = Name)) +
#   geom_tile(data = subset(SppDist, Value !=0),
#             aes(
#     x = Longitude,
#     y = Latitude,
#     fill = log10(Value)
#   ) 
#   ) +
#   facet_wrap(~Model)

# The main issue is that there is no catch data there...

```


# Extra Analysis
## Extra Analysis; Functions

```{r Trans_Spp_Function_All, eval = F ,echo = T,warning = F,message = F}

# Function to determine whether or not a species is transboundary for each model

# Varibales needed
# Spp: Species to be analized, data with presence/absence per gridcell
# Index_EEZ: Reference list of all INDEX that fall within EEZs
# EEZ_Size: Number of grid-cells that each EEZ has
# Neighbours: Reference list of neighbouring countries

# Needs getSppDist

#### For testing 
# Spp <- 600059
# Model <- "All"
# Neighbours <- Neighbour_List
# Coord = CoorG
# __________________________________

# The function
EstTransIndex <- function(Spp,Model,Neighbours,Coord,Save="Y"){
  
  # Get model data from spps
  SppDist <- GetSppDist(Spp,Model,Coord)
  
  # Result 1. Number of Countries that share the species
  
  #____________ ESTIMATING MODEL INDEX (TRESHOLD 1)_________ #
  Trans_Spp <- SppDist %>%
    filter(INDEX %in% Neighbours$INDEX,# Filter data only located within EEZs
           Model != "SAU_C") %>% # Only using observational and modelled data
    mutate(Value = ifelse(Value > 0, 1,0)) %>%
    left_join(EEZ_CellID,
              by = "INDEX") %>% 
    left_join(EEZIDs_List,
              by = "EEZID")
  
  # MODEL INDEX (TRESHOLDS 1 & 2) #
  Model_Index_D <- Trans_Spp %>% 
    group_by(Name,
             TaxonKey,
             Model
    ) %>% 
    summarise(n_cells_spp = n()) %>% 
    select(-n_cells_spp)
  
    #____________ ESTIMATING DISTRIBUTION INDEX (TRESHOLD 3)_________ #
   # The number of species' cells present within each country's EEZ
  
  #Step 1.  Get EEZ id and Neighbour
  Neighbours_EEZ <- Neighbours %>% 
  group_by(EEZID,Country_Territory,Neighbour_Territory) %>% 
  summarise(n=n()) %>% 
  ungroup() %>% 
  select(-n)

  # Step 2. Determines the amount of grids present in each country
  Spp_Grid <- Trans_Spp %>% 
    group_by(TaxonKey,
             Model, 
             EEZID) %>% 
    summarise(n_spp_eez = length(unique(INDEX))) %>% 
    left_join(Neighbours_EEZ,
              by = "EEZID") %>% 
    filter(Country_Territory %in% Trans_Spp$Name, #Filter out unwanted Neighbours (those who don't have grids within but get included because they are Neighbours)
           Neighbour_Territory %in% Trans_Spp$Name)
  
  # Step 3. Sum total grids per Neighbours
  
  # Split dataframes to merge latter
  Country_Territory_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      Model_Index, # Un-comment after producing models x datasets
      TaxonKey,Name=Country_Territory,n_spp_eez
    )
  
  Neighbour_Territory_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      Model_Index,
      TaxonKey,n_spp_eez,Name=Neighbour_Territory, Country_Territory
    )

  # Merge dataframes to get totals per Neighbourds
  Area_Index_D <- full_join(Country_Territory_T,
                           Neighbour_Territory_T, by = c("Name","TaxonKey","Model")) %>%
    rowwise() %>%
    mutate(Spp_Total = sum(n_spp_eez.x,n_spp_eez.y,na.rm=T)) %>% # Total gridcelles per Neighbours
    distinct() %>% # Removes false duplicates from `full_join()`
    rename(Neighbour_Territory = Name,
           n_spp_Country = n_spp_eez.x,
           n_spp_Neighbour = n_spp_eez.y) %>% 
    mutate(Area_Index = n_spp_Country/Spp_Total) %>%  #Estimates the proportion of grids per country
    select(1:4,6,8)

  #____________ FINAL INDEX TABLE_________ #
  Indexes <- Model_Index_D %>% 
  rename(Country_Territory = Name) %>% 
  full_join(Area_Index_D,
            by = c("TaxonKey","Country_Territory","Model")
  ) %>% 
    filter(!is.na(Area_Index))%>%  # Remove cases where the country does not pass the area_index and viceversa
    select(Model,TaxonKey,Country_Territory,Neighbour_Territory,everything())

  ### Save spp dataframe
  
  if(nrow(Indexes) > 0 & Save == "Y"){
    
    File_Name <- paste(Spp,"_Transboundary.csv",sep = "")
    Save_Path <- paste(Results_Path,"All_Models/",File_Name,sep="")
    
    write.csv(Indexes,
              Save_Path,
              row.names = F)
    
  }
  
  if(nrow(Indexes) == 0 & Save == "Y"){
    
# Reads dataset of Non transboundary species
    Non_Transboundary_Data <- fread(paste(Results_Path,"All_Models/","Non_Transboundary_Data.csv",sep=""))
    
    # Get current Spp that is not transboundary 
    Current_Spp <- tibble(Non_trans = Spp)
    
    # Combine new spp with others
    New_Non <- Non_Transboundary_Data %>% 
      bind_rows(Current_Spp)
    
    # Set a name for file and saves data
    New_Non_Name <- paste(Results_Path,"All_Models/","Non_Transboundary_Data.csv",sep="")
    write.csv(New_Non, New_Non_Name, row.names = F)
    
  }
  
  ### Function return
  
  EstTransIndex=Indexes # A dataframe with 
  
}


### Testing Function ####
# Spp <- 600006
# Model <- "All"
# Neighbours <- Neighbour_List
# 
# Tryout <- EstTransIndex(Spp,Model,Neighbours,CoorG,Save="N")
# 
# Over_20 <-Tryout %>% 
#     filter(Area_Index > 0.20,
#            Area_Index < 0.80)
  
# Spp <- NULL
# Model <- NULL

```

## Extra Analysis; Results

### Maps for each model/dataset
```{Tran_country_Map_All, eval =F, echo =F}

World_EEZs_simple <- World_EEZs %>%
  st_transform(crs = 4326) %>% # 4326
  st_simplify(preserveTopology = TRUE, dTolerance = 0.1) %>%
  left_join(TenTwenyfive, by ="Name") #%>%
  # filter(!is.na(n_trans)) #%>%
  # st_transform(crs = 3832)

# head(World_EEZs_simple)
# World_EEZs_simple %>% 
#   filter(Name == "Chile")

pal <- wes_palette("Zissou1", 100, type = "continuous")

Mod <- unique(TenTwenyfive$Model)

# Loop through all variables
for(v in 1:length(Mod)){
  
  Model_List <- Mod[v]
  
  plot <- ggplot(data = subset(World_EEZs_simple,Model %in% Model_List)) +
    geom_sf(aes(fill = n_trans)) +
    scale_fill_gradientn(colours = pal,
                         na.value = "white") +
    ggtheme_map() +
    ggtitle(paste(Model_List))
  
  # Name plot
  Plot_Name <- paste(Model_List,"plot.png",sep="_")
  
  # Save plot
  ggsave(
    plot = plot,
    width = 14,
    height = 10,
    units = "in",
    filename = Plot_Name,
    path = "/Volumes/DATA/JULIANO_NEYMAR/FishForVisa/Figures/All_Models/"
  )
    
  }

```




# Old code
```{r OLD_funEstNeighbours, eval = F, echo=T}
# Determine which countries are Neighbours

# Method adopted from Adrew Heiss
# https://gist.github.com/andrewheiss/926b9d60a26e29f6bf32

EstNeighbours <- function(Shapefile){
  
  # Get the list using the poly2nb function
  
  Neighbour_List <- poly2nb(Shapefile)
  
  # Convert te nb data to a Matrix of crossing references
  Neighbour_Matrix <- nb2mat(Neighbour_List,
                            style="B", 
                            zero.policy=TRUE)
  
  # Rename the matrix axis
  colnames(Neighbour_Matrix) <- rownames(Neighbour_Matrix)
  
  
  # Get the names of the countries for identifying them
  Country_Names <- tibble(id = row.names(Shapefile@data),
                              Country_Territory = as.character(Shapefile@data$Name),
                              Neighbour_Territory = Country_Territory,
                              EEZID = Shapefile@data$EEZID # specific of SAU sf
                              )
  
  # Clean up and transform the Neighbour matrix
  Neighbours <- as.data.frame(Neighbour_Matrix) %>%
    mutate(country = row.names(.)) %>%  # Convert row names to actual column
    gather(Neighbour, present, -country) %>%  # Convert to long
    filter(present == 1) %>%  # Only look at cells with a match
    # Add country names
    left_join(select(Country_Names,
                     -Neighbour_Territory), by=c("country" = "id")) %>%
    left_join(select(Country_Names, 
                     -Country_Territory), by=c("Neighbour" = "id")) %>% 
    select(EEZID = EEZID.x,Country_Territory,Neighbour_Territory) # select final column
 
    # Merge them with SAU data
  
  DBEM_Neighbours_Data <- EEZIDs_List %>% 
  left_join(EEZ_CellID, 
            by = "EEZID") %>% # Asign EEZ id to each country
  left_join(Neighbours, 
            by = "EEZID") %>% # Include all Neighbouring countries 
  filter(Neighbour_Territory != "NA") %>% 
  left_join(Coor,
            by = "INDEX") # Inclu
  
  return(DBEM_Neighbours_Data)
   
}


### Test function

# Subset data for testing function
# SAU_Regions <- as.data.frame(unique(World_EEZs$Name))

# Test_Countries <-c("Mexico (Atlantic)","Mexico (Pacific)","Guatemala (Caribbean)","Guatemala (Pacific)","Belize")
# Test <- World_EEZs[World_EEZs@data$Name %in% Test_Countries, ]

# Running function
# getNeighbours(Test)

#### Works beautifully! 

```

```{r Trans_Spp_Function, eval= T ,echo = T,warning = F,message = F}

# Function to determine whether or not a species is transboundary

# Varibales needed
# Spp: Species to be analized, data with presence/absence per gridcell
# Index_EEZ: Reference list of all INDEX that fall within EEZs
# EEZ_Size: Number of grid-cells that each EEZ has
# Neighbours: Reference list of neighbouring countries

# Needs getSppDist

#### For testing 
# Spp <- 600059
 #Model <- "All"
 #Neighbours <- Neighbour_List
 #Coord = CoorG
# __________________________________

# The function
EstTransIndex <- function(Spp,Model,Neighbours,Coord,Save="Y"){
  
  # Get model data from spps
  SppDist <- GetSppDist(Spp,Model,Coord)
  
  # Result 1. Number of Countries that share the species
  
  #____________ ESTIMATING MODEL INDEX (TRESHOLD 1)_________ #
  Trans_Spp <- SppDist %>%
    filter(INDEX %in% Neighbours$INDEX,# Filter data only located within EEZs
           Model != "SAU_C") %>% # Only using observational and modelled data
    mutate(Value = ifelse(Value > 0, 1,0)) %>%  
    filter(Value > 0) %>%
    group_by(TaxonKey,
             INDEX
    ) %>%
    summarise(Model_Index = mean(Value,na.rm=T)
    ) %>%
    filter(Model_Index > 0) %>%
    # ____________ ESTIMATING FUNDAMENTAL NICHE (TRESHOLD 2)_________ #
    left_join(SppDist,
              by = c("TaxonKey","INDEX")) %>%
    filter(Model == "SAU_C", # Only keeping cells where SAU catch exists
           Value > 0) %>%
    mutate(Model_Index = Model_Index*100) %>%
    select(-Model, -Value, -Latitude,-Longitude) %>%
    left_join(EEZ_CellID,
              by = "INDEX") %>% 
    left_join(EEZIDs_List,
              by = "EEZID")
  
  # MODEL INDEX (TRESHOLDS 1 & 2) #
  Model_Index_D <- Trans_Spp %>% 
    group_by(Name,
             TaxonKey,
             Model_Index
    ) %>% 
    summarise(n_cells_spp = n()) %>% 
    select(-n_cells_spp)
  
  #____________ ESTIMATING DISTRIBUTION INDEX (TRESHOLD 3)_________ #
  # The number of species' cells present within each country's EEZ
  
  #Step 1.  Get EEZ id and Neighbour
  Neighbours_EEZ <- Neighbours %>% 
    group_by(EEZID,Country_Territory,Neighbour_Territory) %>% 
    summarise(n=n()) %>% 
    ungroup() %>% 
    select(-n)
  
  # Step 2. Determines the amount of grids present in each country
  Spp_Grid <- Trans_Spp %>% 
    group_by(TaxonKey,
             Model_Index, # Un-comment after producing models x datasets
             EEZID) %>% 
    summarise(n_spp_eez = length(unique(INDEX))) %>% 
    left_join(Neighbours_EEZ,
              by = "EEZID") %>% 
    filter(Country_Territory %in% Trans_Spp$Name, #Filter out unwanted Neighbours (those who don't have grids within but get included because they are Neighbours)
           Neighbour_Territory %in% Trans_Spp$Name)
  
  # Step 3. Sum total grids per Neighbours
  
  # Split dataframes to merge latter
  Country_Territory_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      Model_Index, # Un-comment after producing models x datasets
      TaxonKey,
      Name=Country_Territory,
      n_spp_eez
    )
  
  Neighbour_Territory_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      Model_Index,
      TaxonKey,n_spp_eez,
      Name=Neighbour_Territory, 
      Country_Territory
    )
  
  # Merge dataframes to get totals per Neighbourds
  Area_Index_D <- full_join(Country_Territory_T,
                            Neighbour_Territory_T, 
                            by = c("Model_Index","Name","TaxonKey")
  ) %>%
    rowwise() %>%
    mutate(Spp_Total = sum(n_spp_eez.x,n_spp_eez.y,na.rm=T)) %>% # Total gridcelles per Neighbours
    distinct() %>% # Removes false duplicates from `full_join()`
    rename(Neighbour_Territory = Name,
           n_spp_Country = n_spp_eez.x,
           n_spp_Neighbour = n_spp_eez.y) %>% 
    mutate(Area_Index = n_spp_Country/Spp_Total) %>%  #Estimates the proportion of grids per country
    select(1:3,6,8)
  
  #____________ FINAL INDEX TABLE_________ #
  Indexes <- Model_Index_D %>% 
    rename(Country_Territory = Name) %>% 
    full_join(Area_Index_D,
              by = c("TaxonKey","Country_Territory","Model_Index")
    ) %>% 
    filter(!is.na(Area_Index),
           !is.na(Model_Index) # Uncomment after producing Models x datasets
    )%>%  # Remove cases where the country does not pass the area_index and viceversa
    select(TaxonKey,Country_Territory,Neighbour_Territory,everything())
  
  ### Save spp dataframe
  
  if(nrow(Indexes) > 0 & Save == "Y"){
    
    File_Name <- paste(Spp,"_Transboundary.csv",sep = "")
    Save_Path <- paste(Results_Path,File_Name,sep="")
    
    write.csv(Indexes,
              Save_Path,
              row.names = F)
    
  }
  
  if(nrow(Indexes) == 0 & Save == "Y"){
    
    # Reads dataset of Non transboundary species
    Non_Transboundary_Data <- fread(paste(Results_Path,"Non_Transboundary_Data.csv",sep=""))
    
    # Get current Spp that is not transboundary 
    Current_Spp <- tibble(TaxonKey = Spp)
    
    # Combine new spp with others
    New_Non <- Non_Transboundary_Data %>% 
      bind_rows(Current_Spp)
    
    # Set a name for file and saves data
    New_Non_Name <- paste(Results_Path,"Non_Transboundary_Data.csv",sep="")
    write.csv(New_Non, New_Non_Name, row.names = F)
    
  }
  
  ### Function return
  
  EstTransIndex=Indexes # A dataframe with 
  
}
```
